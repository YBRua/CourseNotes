\chapter{First Order Logic}

\emph{"All men are mortal. Socrates is a man. Socrates is mortal."}

\section{Syntax of First-Order Logic}

We start with the symbols of a \textbf{first-order language} $\mathbb{L}$

There are two types of symbols

\begin{itemize}
    \item \textbf{Logical symbols}
    \item Non-logical symbols, a.k.a. \textbf{parameters}
\end{itemize}

\subsection{Symbols}

\subsubsection{Logical Symbols}

In a first-order language $\mathbb{L}$, we have the following symbols

\begin{enumerate}
    \item \textbf{Parentheses}. Two symbols `(' and `)'.
    \item \textbf{Logical connective symbols}. $\to$ and $\neg$
    \item \textbf{Variables}. An enumerable list of symbols $v_1,\dots,v_n,\dots$
    \item \textbf{Identity or Equalily Symbol} $=$ or $\doteq$. It may or may not be present in a particular first-order language
\end{enumerate}

Notice that we do not need $\vee$, $\wedge$. $\leftrightarrow$ because $\{\to, \neg\}$ is complete.

\subsubsection{Parameters}

\begin{enumerate}
    \item \textbf{Universal quantifier}. $\forall$
    \item For each $n>0$, there is a set (possibly empty) of objects called n-ary (or n-place) \textbf{predicate symbols}
    \item For each $n>0$, there is a set (possibly empty) of objects called n-ary (or n-place) \textbf{function symbols}
    \item A set of (possibly empty) of objects \textbf{constant symbols}
\end{enumerate}

\subsubsection{Further Requirements}

\begin{itemize}
    \item $\doteq$ is a 2-ary predicate symbols
    \item There is at least one predicate symbol
    \item The symbols are distinct, and no symbol is equal to a finite sequence of other symbols
\end{itemize}

\subsubsection{Example: Set Theory as First-Order Logic}

The Set Theory can be described by the following language

\begin{itemize}
    \item Equality
    \item Predicate symbols: 2-place $\dot{\in}$
    \item Constant symbols: empty set $\dot{\emptyset}$
    \item Function symbols: None
\end{itemize}

Note that the symbols are (currently) just interpreted as symbols and they do not have semantic meanings.

\begin{remark}
    We do not put restrictions or requirements on number of predicate, function or constant symbols.
\end{remark}

\subsection{Expressions}

An \textbf{expression} in a language $\mathbb{L}$ is a finite sequence of symbols.

\subsubsection{Terms}

\begin{definition}[Term Building Operation]
    \label{def:TermBuildingOperation}
    Given any n-ary function symbol $f$, the term-building operation $\mathcal{F}_f$ is defined by
    \[ \mathcal{F}_f (\sigma_1,\dots,\sigma_n) = f \sigma_1\dots\sigma_n \]
    We call $\sigma_i$ the arguments to $f$
\end{definition}

\begin{definition}[Term]
    \label{def:Term}
    A \textbf{term} is an expression built up from constant symbols and variables by applying some finite times of term-building operations.
    
\end{definition}

For example, let $f$ and $g$ be 2-ary and 3-ary function symbols, then $gfc_1c_2v_3c_1$ is a term.

\begin{definition}[Term Sequence]
    \label{def:TermSequence}
    A \textbf{term sequence} is a finite sequence $t_1,\dots,t_n$ of expressions s.t. each $t_i$ is
    \begin{itemize}
        \item either a variable, a constant
        \item or is in the form of $f\sigma_1\dots\sigma_k$ where $f$ is a $f$-ary function and each $\sigma_1,\dots,\sigma_k$ occurs earlier in the sequence
    \end{itemize}
\end{definition}

\begin{proposition}
    An expression $t$ is a term iff there is a term sequence $t_1,\dots,t_n$ such that $t=t_n$
\end{proposition}

\subsubsection{Atomic Formulas}

\begin{definition}[Atomic Formula]
    \label{def:AtomicFormula}
    An expression is an \textbf{atomic formula} if it is of the form $P t_1\dots t_n$ where $t_1,\dots,t_n$ are terms and $P$ is a n-ary predicate symbol.
\end{definition}

\subsection{Well-Formed Formulas}

\begin{definition}[Formula-Building Operations]
    \label{def:FormulaBuildingOperation}
    \begin{itemize}~{}
        \item $\xi_\neg(\alpha) = (\neg \alpha)$
        \item $\xi_\to(\alpha, \beta) = (\alpha\to\beta)$
        \item $\mathcal{Q}_i(\gamma) = \forall v_i\gamma$
    \end{itemize}
\end{definition}

\begin{definition}[Well-Formed Formula]
    A \textbf{well-formed formula} (wff) is an expression built up from atomic formulas by applying some finite times of term-building operations.
\end{definition}

\begin{definition}[Well-Formed Sequence]
    A \textbf{well-formed sequence} is a finite sequence $\alpha_1,\dots,\alpha_n$ of expressions such that each $\alpha_i$ is
    \begin{itemize}
        \item either an atomic formula
        \item or is of the form of $(\neg \beta)$ or $(\beta\to\gamma)$ where $\beta$ and $\gamma$ occur earlier in the list
        \item or is of the form $\forall v_i\beta$ where $\beta$ occurs earlier in the list
    \end{itemize}
\end{definition}

\begin{proposition}
    The expression $\alpha$ is a wff if there is a well-formed sequence $\alpha_1,\dots,\alpha_k$ such that $\alpha = \alpha_k$
\end{proposition}

\subsection{Abbreviations}

\begin{itemize}
    \item $(\alpha\vee\beta)$ abbreviates $((\neg\alpha)\to\beta)$
    \item $(\alpha\wedge\beta)$ abbreviates $(\neg(\alpha \to (\neg\beta)))$
    \item $(\alpha\leftrightarrow\beta)$ abbreviates $(\alpha\to\beta)\wedge(\beta\to\alpha)$
    \item $\exists x\alpha$ abbreviates $(\neg\forall x(\neg\alpha))$
    \item $u\doteq t$ abbreviates $\doteq ut$
    \item $u \dot{\neq} t$ abbreviates $\dot{\neq} ut$
    \item Outer-most parentheses can be omitted
    \item $\neg$, $\forall$, $\exists$ apply to as little as possible
    \item $\wedge$, $\vee$ apply to as little as possible, subject to previous operators
    \item Grouping for repeated connectives is to the right
\end{itemize}

\subsection{Free Occurrence of Variables}

\begin{definition}[Free Occurrence]
    The variable $x$ \textbf{occurs free} in an atomic wff $\varphi$ iff it occurs in $\varphi$.

    $x$ \textbf{occurs free} in $\neg\alpha$ iff $x$ occurs free in $\alpha$.

    $x$ \textbf{occurs free} in $\alpha\to\beta$ iff $x$ occurs free in $\alpha$ or in $\beta$.

    $x$ \textbf{occurs free} in $\forall y \alpha$ iff $x$ occurs free in $\alpha$ and $x \neg y$.
\end{definition}

\begin{definition}[Sentence]
    $\varphi$ is a \textbf{sentence} iff no variable occurs free in $\varphi$.
\end{definition}
\begin{remark}
    Sentences are usually represented by $\sigma$ or $\tau$.
\end{remark}

We provide some examples

\begin{itemize}
    \item $\dot{0} \dot{<} \dot{1}$ does not have any free occurrence. It is a sentence,
    \item $\forall x(x\dot{<}y)$. $y$ occurs free but $x$ does not.
    \item $\forall x(\neg x \dot{<} \dot{0})$. No free occurrence.
    \item $\forall x\forall y (x \dot{<} y \to \exists z x\dot{<}z\wedge z\dot{<}y)$. No free occurrence.
\end{itemize}

\section{Semantics of First-Order Logic}

\subsection{Structures}

\begin{definition}
    Given a first order language $\mathbb{L}$, a \textbf{structure} $\mathfrak{A}$ for $\mathbb{L}$ consists of
    \begin{itemize}
        \item A non-empty set called the \textbf{universe} or \textbf{domain} of the structure, written as $|\mathfrak{A}|$
        \item For each n-ary predicate symbol $P$ of $\mathcal{L}$, other than $\doteq$, an n-ary relation $\mathbb{P}^{\mathfrak{A}}$ on $|\mathfrak{A}|$
        \item $\doteq^{\mathfrak{A}}$ is the identity relation on $|\mathfrak{A}|$. $\doteq^{\mathfrak{A}} = \{(a,b)|a,b\in|\mathfrak{A}, a =b|\}$
        \item For each n-ary function symbol $f$ of $\mathbb{L}$, an n-ary ooperation on the universe, i.e. an n-ary function $f^{\mathfrak{A}}: |\mathfrak{A}|\times\cdots\times|\mathfrak{A}|\mapsto|\mathfrak{A}|$
        \item For each constant symbol $c$ of $\mathbb{L}$, $c^{\mathfrak{A}}\in|\mathfrak{A}|$
    \end{itemize}
\end{definition}

\subsection{Assignments}

Let $\mathfrak{A}$ be a structure for language $\mathbb{L}$. Let $V$ be the set of variables, and $T$ be the set of terms.

\begin{definition}[Assignment Functions]
    An \textbf{assignment} for $\mathfrak{A}$ is a function $s:V\mapsto|\mathfrak{A}|$.
\end{definition}

\begin{definition}[Assignment to Terms]
    An assignment $s$ is extended to a function $\bar{s}:T\mapsto|\mathfrak{A}|$.
    \begin{itemize}
        \item $\bar{s}(v) = s(v)$ if $v$ is a variable
        \item $\bar{s}(c) = c^{\mathfrak{A}}$ if $c$ is a constant
        \item $\bar{s}(ft_1\dots t_n) = f^{\mathfrak{A}}(\bar{s}(t_1),\dots,\bar{s}(t_n))$ if $f$ is a n-ary function symbol and $t_1,\dots,t_n$ are terms
    \end{itemize}
\end{definition}

\subsubsection{Changing the Assignment Function}

Let $s$ be an assignment function, $x$ be a variable and $a\in\mathfrak{A}$. Then $s(x|a)$ is the new assignment, where for each variable $y$

\[s(x|a)(y) = \begin{cases}
    s(y) &\quad \text{if $(y\neq x)$}\\
    a &\quad \text{if $(y=x)$}
\end{cases}\]

This operation actually ``overrides'' the assignment of $s$ to $x$ and makes the assignment to $x$ equal to $a$.

\subsection{Satisfaction}

Given a first-order language $\mathbb{L}$, let $\mathfrak{A}$ be a structure for $\mathbb{L}$, let $s$ be an assignment for $\mathbb{L}$ and let $\varphi$ be a wff in $\mathbb{L}$. We denote $\mathfrak{A}$ to satisfy $\varphi$ with $s$ by $\vDash_{\mathfrak{A}}\varphi[s]$

Informally, it means ``\emph{The translation of $\varphi$ determined by $\mathfrak{A}$, where a variable $x$ is translated as $s(x)$, is true}''

\subsubsection{Satisfaction for Atomic Formulas}

\begin{definition}
    Given a language $\mathbb{L}$ and a structure $\mathfrak{A}$, let $s$ be an assignment, let $P$ be a n-ary predicate,
    \[ \vDash_{\mathfrak{A}} Pt_1\dots t_n[s] \Leftrightarrow (\bar{s}(t_1),\dots,\bar{s}(t_n)) \in P^{\mathfrak{A}} \]
    \[ \vDash_{\mathfrak{A}} \doteq t_1t_2[s] \Leftrightarrow \bar{s}(t_1) = \bar{s}(t_2) \]
\end{definition}

\subsubsection{Satisfaction for WFF}

\begin{definition}
    Suppose $\vDash_{\mathfrak{A}}\alpha[s]$ and $\vDash_{\mathfrak{A}}\beta[s]$ have been defined, then
    \begin{itemize}
        \item $\vDash_{\mathfrak{A}} \neg\alpha[s]$ iff not $\vDash_{\mathfrak{A}}\alpha[s]$
        \item $\vDash_{\mathfrak{A}}\alpha\to\beta[s]$ iff $\vDash_{\mathfrak{A}}\alpha[s]\Longrightarrow\vDash_{\mathfrak{A}}\beta[s]$
        \item $\vDash_{\mathfrak{A}}\forall x \alpha[s]$ iff $\forall a\in|\mathfrak{A}|$, $\vDash_{\mathfrak{A}}\alpha[s(x|a)]$
    \end{itemize}
\end{definition}

If $\vDash_{\mathfrak{A}}\varphi[s]$, we say \emph{$\mathfrak{A}$ satisfies $\varphi$ with $s$}, or \emph{$s$ satisfies $\varphi$ in the structure $\mathfrak{A}$}

\subsubsection{Satisfaction Depends Only on Variables that Occur Free}

\begin{lemma}
    \label{lem:LemmaForFreeOccurrenceThm}
    Let $\mathfrak{A}$ be a structure for $\mathbb{L}$, $s_1, s_2$ be two assignment for $\mathfrak{A}$ and $\varphi$ be a term of $\mathbb{L}$.

    If $s_1(x)=s_2(x)$ for every $x$ that occurs in $t$, then
    \[ \bar{s}_1(t) = \bar{s}_2(t) \]
\end{lemma}
\begin{proof}
    Proof by induction on $t$.
    \begin{itemize}
        \item[Base] If $t=c$ is a constant. It is straightforward that $\bar{s}_1(t) = \bar{s}_2(t) = c$. If $t=x$ is a variable, then by assumption we know that $\bar{s}_1(x) = s_1(x) = s_2(x) = \bar{s}_2(x)$. So we are done.
        \item[Induction] Consider a term $t=ft_1\dots t_n$. By inductive hypothesis we know that $\forall i$, $\bar{s}_1(t_i) = \bar{s}_2(t_i)$. $\bar{s}_1(t) = f^{\mathfrak{A}}(\bar{s}_1(t), \dots, \bar{s}_1(t) = f^{\mathfrak{A}}(\bar{s}_2(t), \dots, \bar{s}_2(t)) = \bar{s}_2(t)$.
    \end{itemize}
\end{proof}

\begin{theorem}
    Let $\mathfrak{A}$ be a structure for $\mathbb{L}$, $s_1, s_2$ be two assignment for $\mathfrak{A}$ and $\varphi$ be a wff of $\mathbb{L}$.

    If $s_1(x)=s_2(x)$ for every $x$ that occurs free in $\varphi$, then
    \[ \vDash_{\mathfrak{A}}\varphi[s_1] \Leftrightarrow \vDash_{\mathfrak{A}}\varphi[s_2] \]
\end{theorem}

\begin{proof}
    Prove by induction on $\varphi$.
    \begin{itemize}
        \item[Base] If $\varphi$ is an atomic formula $Pt_1\dots t_n$.
        \[ \vDash_{\mathfrak{A}} \varphi [s_1] \Leftrightarrow P^{\mathfrak{A}}(\bar{s}_1(t_1),\dots,\bar{s}_1(t_n)) \]
        \[ \vDash_{\mathfrak{A}} \varphi [s_2] \Leftrightarrow P^{\mathfrak{A}}(\bar{s}_2(t_1),\dots,\bar{s}_2(t_n)) \]

        We need to prove that the two RHSes are equivalent. By Lemma~\ref{lem:LemmaForFreeOccurrenceThm} we know that all the terms are equal under $s_1$ and $s_2$, and therefore $\vDash_{\mathfrak{A}} \varphi [s_1] = \vDash_{\mathfrak{A}} \varphi [s_2]$.

        \item[Induction] Consider $\varphi=\neg\alpha$.
        \[ \vDash_{\mathfrak{A}}(\neg\alpha)[s_1] \Leftrightarrow \nvDash_{\mathfrak{A}}\alpha[s_1] \Leftrightarrow \nvDash_{\mathfrak{A}}\alpha[s_2] \Leftrightarrow \vDash_{\mathfrak{A}}(\neg\alpha)[s_2] \]

        The case $\varphi = \alpha\to\beta$ is similar.

        Consider the case $\forall x \alpha$. We want to prove
        \[ \fosat{A}{\forall x\alpha}{s_1} \Leftrightarrow \fosat{A}{\forall x\alpha}{s_2} \]
        which is equivalent to
        \[ \forall a\in|\mathfrak{A}|\fosat{A}{\alpha}{s_1(x|a)} \Leftrightarrow \forall a \in |\frakA| \fosat{A}{\alpha}{s_2(x|a)} \]

        We only need to prove that
        \[ \forall y \text{occurring free in $\alpha$}, s_1(x|a)(y) = s_2(x|a)(y) \]

        If $y\neq x$, then $y$ is still occurring free in $\alpha$, and by inductive hypothesis they should equal. If $y=x$, then both sides are $a$. So we are done.
    \end{itemize}
\end{proof}
\begin{remark}
    This theorem is somewhat similar to the theorem in sentential logic, which states that we only need to consider sentence symbols. Similarly, in first-order logic, we only need to consider variables that occur free.
\end{remark}

\begin{definition}
    Let $\varphi$ be a wff s.t. all variables occurring free in $\varphi$ are included amoing $v_1,\dots,v_k$. Given $a_1,\dots,a_k\in\frakA$.

    \[ \fosatabbr{A}{\varphi}{a_1,\dots,a_k} \]

    means that $\fosat{A}{\varphi}{s}$ for some $s:V\mapsto|\frakA|$ s.t. $s(v_i) = a_i$
\end{definition}

\begin{corollary}
    If $\sigma$ is a sentence then
    \begin{itemize}
        \item either $\fosat{A}{\sigma}{s}$ for every assignment $s$. We say $\sigma$ is true in $\frakA$.
        \item or $\founsat{A}{\sigma}{s}$ for every assignment $s$. We say $\sigma$ is false in $\frakA$
    \end{itemize}
\end{corollary}

Therefore a sentence does not depend on $s$, and we can simply write $\sentsat{A}{\sigma}$ or $\sentunsat{A}{\sigma}$.
