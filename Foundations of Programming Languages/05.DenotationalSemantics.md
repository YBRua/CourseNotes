# Denotational Semantics of IMP

> 指称语义 / 函数语义

## Denotational Semantics

### Motivation

Up till now we have been discussing IMP from the perspective of its *syntax*. This formulation makes it hard to compare two programs of two different languages.

However, note that

$$ c_0 \sim c_1 \Longleftrightarrow (\forall \sigma,\sigma'.\langle c_0, \sigma \rangle \to \sigma' \Leftrightarrow \langle c_1, \sigma \rangle \to \sigma'). $$

Or equivalently,

$$ c_0 \sim c_1 \Longleftrightarrow \{ (\sigma, \sigma') | \langle c_0, \sigma \rangle \to \sigma' \} = \{ (\sigma, \sigma') | \langle c_1, \sigma \rangle \to \sigma' \}. $$

It suggests that we can view programs as pure *input-output transformers*. We can thus define the *semantics* of IMP.

We take the **denotation** of a command to be a partial function on states.

- A program $c$ transforms a state $\sigma$ into $\sigma'$ after its execution (assuming it terminates).

### Notations

Corresponding to arithmetic expressions, boolean expressions and commands, we define three sets of notations

- An arithmetic expression $a \in \mathbf{Aexp}$ denotes a function $\mathcal{A}\llbracket a \rrbracket: \Sigma \mapsto \mathbb{Z}$.
- A boolean expression $b \in \mathbf{Bexp}$ denotes a function $\mathcal{B}\llbracket b \rrbracket: \Sigma \mapsto \{ true,false \}$.
- A command $c$ denotes a function $\mathcal{C}\llbracket c \rrbracket: \Sigma \mapsto \Sigma$.

### Denotational Semantics

We define the denotational semantics by structural induction.

#### Arithmetic Expressions

- $\mathcal{A}\llbracket n \rrbracket(\sigma) \coloneqq n$ for any state $\sigma$.
- $\mathcal{A}\llbracket X \rrbracket(\sigma) \coloneqq \sigma(X)$.
- $\mathcal{A}\llbracket a_0 + a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) + \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$.
- $\mathcal{A}\llbracket a_0 - a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) - \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$
- $\mathcal{A}\llbracket a_0 \times a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) \times \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$

#### Boolean Expressions

- $\mathcal{B}\llbracket true \rrbracket(\sigma) \coloneqq true$.
- $\mathcal{B}\llbracket false \rrbracket(\sigma) \coloneqq false$.
- $\mathcal{B}\llbracket a_0 = a_1 \rrbracket(\sigma) \coloneqq true \textbf{ if } \mathcal{A}\llbracket a_0 \rrbracket(\sigma) = \mathcal{A}\llbracket a_1 \rrbracket(\sigma) \textbf{ else } false$.
- $\mathcal{B}\llbracket a_0 \le a_1 \rrbracket(\sigma) \coloneqq true \textbf{ if } \mathcal{A}\llbracket a_0 \rrbracket(\sigma) \le \mathcal{A}\llbracket a_1 \rrbracket(\sigma) \textbf{ else } false$.
- $\mathcal{B}\llbracket \neg b \rrbracket(\sigma) \coloneqq \neg \mathcal{B}\llbracket b \rrbracket(\sigma)$.
- $\mathcal{B}\llbracket b_0 \land b_1 \rrbracket(\sigma) \coloneqq \mathcal{B}\llbracket b_0 \rrbracket(\sigma) \land \mathcal{B}\llbracket b_1 \rrbracket(\sigma)$.
- $\mathcal{B}\llbracket b_0 \lor b_1 \rrbracket(\sigma) \coloneqq \mathcal{B}\llbracket b_0 \rrbracket(\sigma) \lor \mathcal{B}\llbracket b_1 \rrbracket(\sigma)$.

#### Commands

##### Skip

$$\mathcal{C}\llbracket \texttt{skip} \rrbracket \coloneqq \{(\sigma, \sigma) | \sigma \in \Sigma\} $$

$$ \mathcal{C}\llbracket \texttt{skip} \rrbracket(\sigma) \coloneqq \sigma $$

##### Assignment

$$\mathcal{C}\llbracket X \coloneqq a \rrbracket \coloneqq \{ (\sigma, \sigma[\mathcal{A}\llbracket a \rrbracket(\sigma)/X]) | \sigma \in \Sigma \}$$

$$\mathcal{C}\llbracket X \coloneqq a \rrbracket(\sigma) \coloneqq \sigma[\mathcal{A}\llbracket a \rrbracket(\sigma)/X]$$

##### Sequential Composition

$$\mathcal{C}\llbracket c_0;c_1 \rrbracket \coloneqq \mathcal{C}\llbracket c_0 \rrbracket \circ \mathcal{C} \llbracket c_1 \rrbracket$$

$$\mathcal{C}\llbracket c_0;c_1 \rrbracket(\sigma) \coloneqq \mathcal{C}\llbracket c_1 \rrbracket(\mathcal{C}\llbracket c_0 \rrbracket(\sigma))$$

##### Conditional Branches

$$ \mathcal{C}\llbracket \texttt{if } b \texttt{ then } c_0 \texttt{ else } c_1 \rrbracket $$

is the union of

- $\{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket c_0 \rrbracket \}$.
- $\{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket c_1 \rrbracket \}$.

$$\mathcal{C}\llbracket \texttt{if } b \texttt{ then } c_1 \texttt{ else } c_1 \rrbracket(\sigma) = \begin{cases}
    \mathcal{C}\llbracket c_0 \rrbracket(\sigma) &\quad \mathcal{B}\llbracket b \rrbracket(\sigma) = true\\
    \mathcal{C}\llbracket c_1 \rrbracket(\sigma) &\quad \mathcal{B}\llbracket b \rrbracket(\sigma) = false
\end{cases}$$

##### While Loops

> Uh oh.

$$ w \coloneqq \texttt{while } b \texttt{ do } c $$

Note that since

$$ w \sim \texttt{if } b \texttt{ then } c;w \texttt{ else } \texttt{skip}, $$

a direct attempt would be to define

$$ \mathcal{C}\llbracket w \rrbracket = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{\mathcal{C}\llbracket w \rrbracket} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

However, note that this definition is *recursive* so it is NOT well-defined. Instead $\mathcal{C}\llbracket w \rrbracket$ should be the solution to the following set equation.

$$ \underline{R} = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{R} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

- The set $R = \{ (\sigma, \sigma) | \sigma \in \Sigma \}$ is a solution when $c = \texttt{skip}$.
  - However, if $b = true$, we want $\mathcal{C}\llbracket w \rrbracket = \emptyset$. So this solution is inconsistent with the operational semantics.
  - I.e., not every solution is acceptable. We want the solution to agree with the operational semantics.
- $\mathcal{C}\llbracket w \rrbracket$ should be the solution with the *least* information.

Spoiler: It's the minimal fixed point. We defer the discussion to subsequent sections, and we first introduce some additional tools.

## Complete Partial Orders

### Upper Bounds

#### Upper Bounds

Let $(P, \sqsubseteq)$ be a partial order and $X$ be a subset of $P$, $p \in P$ is an upper bound of $X$ if

$$ \forall q \in X. q \sqsubseteq p. $$

#### Least Upper Bound

$p \in P$ is a **least upper bound (LUB)** of $X$ if

- $p$ is an upper bound of $X$, and
- for all upper bound $q$ of $X$, $p \sqsubseteq q$.

For any $X \subseteq P$, $X$ has *at most one* LUB (it might not exist). The LUB (if exists) is denoted by $\sqcup X$.

### Complete Partial Orders (CPO)

#### $\omega$-Chains

Let $(P, \sqsubseteq)$ be a partial order. An **$\omega$-chain** in $P$ is an infinite sequence $d_0,\dots$ in $P$ such that

$$ d_0 \sqsubseteq d_1 \sqsubseteq \cdots \sqsubseteq d_n \sqsubseteq \cdots $$

#### Complete Partial Order

$(P, \sqsubseteq)$ is a **complete partial order (CPO)** if for any $\omega$-chain in $P$, the least upper bound

$$ \bigsqcup_{n \in \omega} d_n \coloneqq \bigsqcup \{ d_n | n \in \omega \} = \bigsqcup \{ d_0,\dots,d_n,\dots \} $$

exists in $P$.

#### Least Element

Let $(P, \sqsubseteq)$ be a partial order. $p \in P$ is a **least element** if $\forall q \in P. p \sqsubseteq q$.

Note that if the least element exists, it is unique.

#### CPO with Bottom

Let $(P, \sqsubseteq)$ be a CPO. It is a **CPO with bottom** if $P$ has a (unique) least element $\bot_P$.

## Continuous Functions

> By continuous function we mean continuous function in the field of computation theory, though it is similar to the one in mathematical analysis.

### Monotonic Function

### Continuous Function

Let $(D, \sqsubseteq_D), (E, \sqsubseteq_E)$ be CPOs. A function $f: D \mapsto E$ is **continuous** if

- $f$ is monotonic.
- For all $\omega$-chains $d_0 \sqsubseteq d_1 \sqsubseteq \cdots \sqsubseteq d_n \sqsubseteq \cdots$ in $D$, we have
  $$ \bigsqcup_{n \in \omega} f(d_n) = f(\bigsqcup_{n \in \omega} d_n) $$

Note that in this definition, *continuity implies monotonicity*.

## Fixed Points

Let $(D, \sqsubseteq_D)$ be a partial order and $f: D \mapsto D$ be a function. An element $d \in D$ is a **fixed point** of $f$ if $f(d) = d$ and a **prefixed point** of $f$ if $f(d) \sqsubseteq d$.

### The Fixed-Point Theorem

Suppose

- $(D, \sqsubseteq_D)$: a CPO with bottom $\bot_D$.
- $f: D \mapsto D$: a continuous function.
- $\bot_D \sqsubseteq_D f(\bot_D) \sqsubseteq_D \cdots \subseteq_D f^n(\bot_D) \sqsubseteq_D \cdots$
- $\mathrm{fix}(f) \coloneqq \bigsqcup_{n \in \omega} f^n(\bot_D)$.

Then

- $\mathrm{fix}(f)$ is a fixed point of $f$: $f(\mathrm{fix}(f)) = \mathrm{fix}(f)$.
- $\mathrm{fix}(f)$ is the least prefixed point of $f$: $f(d) \sqsubseteq d \Rightarrow \mathrm{fix}(f) \sqsubseteq d$.
- $\mathrm{fix}(f)$ is the least fixed point of $f$: $f(d) = d \Rightarrow \mathrm{fix}(f) \sqsubseteq d$.

## Denotational Semantics: Formal Definition

We now return to the denotational semantics of while loops, where we were stuck,

$$ \mathcal{C}\llbracket w \rrbracket = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket w \rrbracket \circ \mathcal{C}\llbracket c \rrbracket\}. $$

Define $\Gamma: (\Sigma \mapsto \Sigma) \mapsto (\Sigma \mapsto \Sigma)$, i.e., $\Gamma$ taks a function as input and outputs another function. Then we can rewrite as

$$ \underline{\Gamma(F)} = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{F} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

Ideally we want $\mathcal{C}\llbracket w \rrbracket$ to be a fixed point of $\Gamma$,

$$ \Gamma(\mathcal{C}\llbracket w \rrbracket) = \mathcal{C}\llbracket w \rrbracket. $$

That is, we define

$$ \mathcal{C}\llbracket w \rrbracket \coloneqq \mathrm{fix}(\Gamma) = \bigsqcup_{n \in \omega} \Gamma^n(\bot) = \bigcup_{n \in \omega} \Gamma^n(\emptyset). $$

**Note.** To formally establish this, we need to show that

1. $((\Sigma \mapsto \Sigma), \subseteq)$ is a complete partial order.
2. $\Gamma$ is a continuous function for $((\Sigma \mapsto \Sigma), \subseteq)$.

The proof of (1) is rather straightforward since $\subseteq$ ensures that the union of the subsets are compatible.

**Theorem.** For all commands $c$, $\mathcal{C}\llbracket c \rrbracket$ is a partial function from $\Sigma$ to $\Sigma$.

### Examples

#### Example#1

$$ w = \texttt{while } X \le 3 \texttt{ do } X \coloneqq X + 1 $$

#### Example#2

$$ w = \texttt{while } true \texttt{ do } \texttt{skip} $$

- $\mathcal{C}\llbracket w \rrbracket = \emptyset$.

## Equivalence of Denotational and Operational Semantics

The equivalence statements between denotational and operational semantics are given by

$$ \mathcal{A}\llbracket a \rrbracket = \{ (\sigma, n) \in \Sigma \times \mathbb{Z} | \langle a, \sigma \rangle \to n \}. $$

$$ \mathcal{B}\llbracket b \rrbracket = \{ (\sigma, t) \in \Sigma \times \{true, false\} | \langle b, \sigma \rangle \to t \}. $$

$$ \mathcal{C}\llbracket c \rrbracket = \{ (\sigma, \sigma') \in \Sigma \times \Sigma | \langle c, \sigma \rangle \to \sigma' \}. $$

The three equations should be interpreted as: 

> *The set on LHS (denotational semantics) equals to (is equivalent to) the set on RHS (a set defined by the operational semantics).*

Usually proving "operational semantics implies denotational semantics" is easier. Nonetheless both directions are not difficult for IMP thanks to its simplicity.

### Arithmetic Expressions

For arithmetic expressions, we can prove both sides simultaneously by structural induction that

$$ \forall a \in \mathbf{Aexp}.\forall \sigma \in \Sigma.\forall n \in \mathbb{Z}. (\mathcal{A}\llbracket a \rrbracket(\sigma) = n \Leftrightarrow \langle a, \sigma \rangle \to n). $$

### Boolean Expressions

Similar to arithmetic expressions, prove by structural induction that

$$ \forall b \in \mathbf{Bexp}.\forall \sigma \in \Sigma.\forall t \in \{ true, false \}. (\mathcal{B}\llbracket b \rrbracket(\sigma) = t \Leftrightarrow \langle b, \sigma \rangle \to t). $$

### Commands

The proof for commands is more complicated. We start from one direction

#### Operational -> Denotational

$$ \forall c \in \mathbf{Com}.\forall \sigma,\sigma' \in \Sigma.(\langle c, \sigma \rangle \to \sigma' \Rightarrow (\sigma, \sigma') \in \mathcal{C}\llbracket c \rrbracket). $$

Prove by special rule induction.

- $A \coloneqq \{ (c, \sigma, \sigma') | \langle c, \sigma \rangle \to \sigma' \}$. $A$ is the set defined by the rules of operational semantics.
- $Q(c, \sigma, \sigma') \coloneqq (\sigma, \sigma') \in \mathcal{C}\llbracket c \rrbracket$. $Q$ is the predicate that the pair $(\sigma, \sigma')$ falls in the set defined by denotational semantics.

#### Denotational -> Operational

$$ \forall c \in \mathbf{Com}.\forall \sigma,\sigma' \in \Sigma. ((\sigma, \sigma') \in \mathcal{C}\llbracket c \rrbracket \Rightarrow \langle c, \sigma \rangle \to \sigma'). $$

Can be proved by structural induction on $c$.

## Knaster-Tarski's Fixed-Point Theorem

- An alternative fixed-point theorem that does not require complete partial order or continuity.
- Instead it requires the existence of a greatest lower bound.

### Lower Bounds

### Complete Lattices

Let $(D, \sqsubseteq)$ be a partial order. $(D, \sqsubseteq)$ is a **complete lattice** if the greatest lower bound $\sqcap X$ exists for every $X \subseteq D$.

If $(D, \sqsubseteq)$ is a complete lattice, then we denote some special elements by

- Denote **the least element** $\bot = \sqcap D$, i.e., $\forall x \in D. \bot \sqsubseteq x$.
- Denote **the greatest element** $\top = \sqcap \emptyset$, i.e., $\forall x \in D.x \sqsubseteq \top$.

Note that by definition of complete lattice, the least and the greatest elements must exist.

### Knaster-Tarski's Fixed-Point Theorem

Let $(D, \sqsubseteq)$ be a complete lattice, $f: D \mapsto D$ be a monotonic function, $Z \coloneqq \{ d \in D | f(d) = d \}$.
