# Denotational Semantics of IMP

> 指称语义 / 函数语义

## Denotational Semantics

### Motivation

Up till now we have been discussing IMP from the perspective of its *syntax*. This formulation makes it hard to compare two programs of two different languages.

However, note that

$$ c_0 \sim c_1 \Longleftrightarrow (\forall \sigma,\sigma'.\langle c_0, \sigma \rangle \to \sigma' \Leftrightarrow \langle c_1, \sigma \rangle \to \sigma'). $$

Or equivalently,

$$ c_0 \sim c_1 \Longleftrightarrow \{ (\sigma, \sigma') | \langle c_0, \sigma \rangle \to \sigma' \} = \{ (\sigma, \sigma') | \langle c_1, \sigma \rangle \to \sigma' \}. $$

It suggests that we can view programs as pure *input-output transformers*. We can thus define the *semantics* of IMP.

We take the **denotation** of a command to be a partial function on states.

- A program $c$ transforms a state $\sigma$ into $\sigma'$ after its execution (assuming it terminates).

### Notations

Corresponding to arithmetic expressions, boolean expressions and commands, we define three sets of notations

- An arithmetic expression $a \in \mathbf{Aexp}$ denotes a function $\mathcal{A}\llbracket a \rrbracket: \Sigma \mapsto \mathbb{Z}$.
- A boolean expression $b \in \mathbf{Bexp}$ denotes a function $\mathcal{B}\llbracket b \rrbracket: \Sigma \mapsto \{ true,false \}$.
- A command $c$ denotes a function $\mathcal{C}\llbracket c \rrbracket: \Sigma \mapsto \Sigma$.

### Denotational Semantics

We define the denotational semantics by structural induction.

#### Arithmetic Expressions

- $\mathcal{A}\llbracket n \rrbracket(\sigma) \coloneqq n$ for any state $\sigma$.
- $\mathcal{A}\llbracket X \rrbracket(\sigma) \coloneqq \sigma(X)$.
- $\mathcal{A}\llbracket a_0 + a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) + \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$.
- $\mathcal{A}\llbracket a_0 - a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) - \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$
- $\mathcal{A}\llbracket a_0 \times a_1 \rrbracket(\sigma) \coloneqq \mathcal{A}\llbracket a_0 \rrbracket(\sigma) \times \mathcal{A}\llbracket a_1 \rrbracket(\sigma)$

#### Boolean Expressions

- $\mathcal{B}\llbracket true \rrbracket(\sigma) \coloneqq true$.
- $\mathcal{B}\llbracket false \rrbracket(\sigma) \coloneqq false$.
- $\mathcal{B}\llbracket a_0 = a_1 \rrbracket(\sigma) \coloneqq true \textbf{ if } \mathcal{A}\llbracket a_0 \rrbracket(\sigma) = \mathcal{A}\llbracket a_1 \rrbracket(\sigma) \textbf{ else } false$.
- $\mathcal{B}\llbracket a_0 \le a_1 \rrbracket(\sigma) \coloneqq true \textbf{ if } \mathcal{A}\llbracket a_0 \rrbracket(\sigma) \le \mathcal{A}\llbracket a_1 \rrbracket(\sigma) \textbf{ else } false$.
- $\mathcal{B}\llbracket \neg b \rrbracket(\sigma) \coloneqq \neg \mathcal{B}\llbracket b \rrbracket(\sigma)$.
- $\mathcal{B}\llbracket b_0 \land b_1 \rrbracket(\sigma) \coloneqq \mathcal{B}\llbracket b_0 \rrbracket(\sigma) \land \mathcal{B}\llbracket b_1 \rrbracket(\sigma)$.
- $\mathcal{B}\llbracket b_0 \lor b_1 \rrbracket(\sigma) \coloneqq \mathcal{B}\llbracket b_0 \rrbracket(\sigma) \lor \mathcal{B}\llbracket b_1 \rrbracket(\sigma)$.

#### Commands

##### Skip

$$\mathcal{C}\llbracket \texttt{skip} \rrbracket \coloneqq \{(\sigma, \sigma) | \sigma \in \Sigma\} $$

$$ \mathcal{C}\llbracket \texttt{skip} \rrbracket(\sigma) \coloneqq \sigma $$

##### Assignment

$$\mathcal{C}\llbracket X \coloneqq a \rrbracket \coloneqq \{ (\sigma, \sigma[\mathcal{A}\llbracket a \rrbracket(\sigma)/X]) | \sigma \in \Sigma \}$$

$$\mathcal{C}\llbracket X \coloneqq a \rrbracket(\sigma) \coloneqq \sigma[\mathcal{A}\llbracket a \rrbracket(\sigma)/X]$$

##### Sequential Composition

$$\mathcal{C}\llbracket c_0;c_1 \rrbracket \coloneqq \mathcal{C}\llbracket c_0 \rrbracket \circ \mathcal{C} \llbracket c_1 \rrbracket$$

$$\mathcal{C}\llbracket c_0;c_1 \rrbracket(\sigma) \coloneqq \mathcal{C}\llbracket c_1 \rrbracket(\mathcal{C}\llbracket c_0 \rrbracket(\sigma))$$

##### Conditional Branches

$$ \mathcal{C}\llbracket \texttt{if } b \texttt{ then } c_0 \texttt{ else } c_1 \rrbracket $$

is the union of

- $\{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket c_0 \rrbracket \}$.
- $\{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket c_1 \rrbracket \}$.

$$\mathcal{C}\llbracket \texttt{if } b \texttt{ then } c_1 \texttt{ else } c_1 \rrbracket(\sigma) = \begin{cases}
    \mathcal{C}\llbracket c_0 \rrbracket(\sigma) &\quad \mathcal{B}\llbracket b \rrbracket(\sigma) = true\\
    \mathcal{C}\llbracket c_1 \rrbracket(\sigma) &\quad \mathcal{B}\llbracket b \rrbracket(\sigma) = false
\end{cases}$$

##### While Loops

> Uh oh.

$$ w \coloneqq \texttt{while } b \texttt{ do } c $$

Note that since

$$ w \sim \texttt{if } b \texttt{ then } c;w \texttt{ else } \texttt{skip}, $$

a direct attempt would be to define

$$ \mathcal{C}\llbracket w \rrbracket = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{\mathcal{C}\llbracket w \rrbracket} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

However, note that this definition is *recursive* so it is NOT well-defined. Instead $\mathcal{C}\llbracket w \rrbracket$ should be the solution to the following set equation.

$$ \underline{R} = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{R} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

- The set $R = \{ (\sigma, \sigma) | \sigma \in \Sigma \}$ is a solution when $c = \texttt{skip}$.
  - However, if $b = true$, we want $\mathcal{C}\llbracket w \rrbracket = \emptyset$. So this solution is inconsistent with the operational semantics.
  - I.e., not every solution is acceptable. We want the solution to agree with the operational semantics.
- $\mathcal{C}\llbracket w \rrbracket$ should be the solution with the *least* information.

Spoiler: It's the minimal fixed point. We defer the discussion to subsequent sections, and we first introduce some additional tools.

## Complete Partial Orders

### Upper Bounds

#### Upper Bounds

Let $(P, \sqsubseteq)$ be a partial order and $X$ be a subset of $P$, $p \in P$ is an upper bound of $X$ if

$$ \forall q \in X. q \sqsubseteq p. $$

#### Least Upper Bound

$p \in P$ is a **least upper bound (LUB)** of $X$ if

- $p$ is an upper bound of $X$, and
- for all upper bound $q$ of $X$, $p \sqsubseteq q$.

For any $X \subseteq P$, $X$ has *at most one* LUB (it might not exist). The LUB (if exists) is denoted by $\sqcup X$.

### Complete Partial Orders (CPO)

#### $\omega$-Chains

Let $(P, \sqsubseteq)$ be a partial order. An **$\omega$-chain** in $P$ is an infinite sequence $d_0,\dots$ in $P$ such that

$$ d_0 \sqsubseteq d_1 \sqsubseteq \cdots \sqsubseteq d_n \sqsubseteq \cdots $$

#### Complete Partial Order

$(P, \sqsubseteq)$ is a **complete partial order (CPO)** if for any $\omega$-chain in $P$, the least upper bound

$$ \bigsqcup_{n \in \omega} d_n \coloneqq \bigsqcup \{ d_n | n \in \omega \} = \bigsqcup \{ d_0,\dots,d_n,\dots \} $$

exists in $P$.

#### Least Element

Let $(P, \sqsubseteq)$ be a partial order. $p \in P$ is a **least element** if $\forall q \in P. p \sqsubseteq q$.

Note that if the least element exists, it is unique.

#### CPO with Bottom

Let $(P, \sqsubseteq)$ be a CPO. It is a **CPO with bottom** if $P$ has a (unique) least element $\bot_P$.

## Continuous Functions

> By continuous function we mean continuous function in the field of computation theory, though it is similar to the one in mathematical analysis.

### Monotonic Function

### Continuous Function

Let $(D, \sqsubseteq_D), (E, \sqsubseteq_E)$ be CPOs. A function $f: D \mapsto E$ is **continuous** if

- $f$ is monotonic.
- For all $\omega$-chains $d_0 \sqsubseteq d_1 \sqsubseteq \cdots \sqsubseteq d_n \sqsubseteq \cdots$ in $D$, we have
  $$ \bigsqcup_{n \in \omega} f(d_n) = f(\bigsqcup_{n \in \omega} d_n) $$

Note that in this definition, *continuity implies monotonicity*.

## Fixed Points

Let $(D, \sqsubseteq_D)$ be a partial order and $f: D \mapsto D$ be a function. An element $d \in D$ is a **fixed point** of $f$ if $f(d) = d$ and a **prefixed point** of $f$ if $f(d) \sqsubseteq d$.

### The Fixed-Point Theorem

Suppose

- $(D, \sqsubseteq_D)$: a CPO with bottom $\bot_D$.
- $f: D \mapsto D$: a continuous function.
- $\bot_D \sqsubseteq_D f(\bot_D) \sqsubseteq_D \cdots \subseteq_D f^n(\bot_D) \sqsubseteq_D \cdots$
- $\mathrm{fix}(f) \coloneqq \bigsqcup_{n \in \omega} f^n(\bot_D)$.

Then

- $\mathrm{fix}(f)$ is a fixed point of $f$: $f(\mathrm{fix}(f)) = \mathrm{fix}(f)$.
- $\mathrm{fix}(f)$ is the least prefixed point of $f$: $f(d) \sqsubseteq d \Rightarrow \mathrm{fix}(f) \sqsubseteq d$.
- $\mathrm{fix}(f)$ is the least fixed point of $f$: $f(d) = d \Rightarrow \mathrm{fix}(f) \sqsubseteq d$.

## Denotational Semantics: Formal Definition

We now return to the denotational semantics of while loops, where we were stuck,

$$ \mathcal{C}\llbracket w \rrbracket = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \mathcal{C}\llbracket w \rrbracket \circ \mathcal{C}\llbracket c \rrbracket\}. $$

Define $\Gamma: (\Sigma \mapsto \Sigma) \mapsto (\Sigma \mapsto \Sigma)$, i.e., $\Gamma$ taks a function as input and outputs another function. Then we can rewrite as

$$ \underline{\Gamma(F)} = \{ (\sigma, \sigma) | \mathcal{B}\llbracket b \rrbracket(\sigma) = false \} \cup \{ (\sigma, \sigma') | \mathcal{B}\llbracket b \rrbracket(\sigma) = true \text{ and } (\sigma, \sigma') \in \underline{F} \circ \mathcal{C}\llbracket c \rrbracket\}. $$

Ideally we want $\mathcal{C}\llbracket w \rrbracket$ to be a fixed point of $\Gamma$,

$$ \Gamma(\mathcal{C}\llbracket w \rrbracket) = \mathcal{C}\llbracket w \rrbracket. $$
