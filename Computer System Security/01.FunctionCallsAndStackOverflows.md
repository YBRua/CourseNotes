# 函数调用与栈溢出

- 关于符号
  - **内存地址.** 低地址在上，高地址在下
  - **堆 (Heap).** 从低地址向高地址扩张
  - **栈 (Stack).** 从高地址向低地址扩张
  - **缓冲区 (Buffer).** 运行时堆和运行时栈。会随程序运行而增长或缩减。

## 函数调用

> 参见操作系统

## 栈

- 存储内容
  - 本地变量
  - 函数返回值
  - 临时空间
- 栈空间管理
  - 进入函数时被分配
  - 返回调用函数时被释放
- 实现方式
  - 栈顶指针寄存器 (ESP). 指向运行函数栈的顶部
  - 栈底指针寄存器 (EBP). 指向运行函数栈的底部
    - 新函数调用时会保存旧函数的上下文，将旧函数的 EBP 压入栈中，在新函数调用结束后恢复
  - 32 位寄存器 ESP/EBP，64 位寄存器 RSP/RBP

## 栈溢出

- 当程序试图将 *超出其容量* 的数据放入缓冲区时

```c
void echo() {
    char buf[4];
    gets(buf);  // buf could be too small
    puts(buf);
}

void call_echo() {
    echo();
}

void main () {
    call_echo();
}
```

- 输入内容可能超出 `buf` 的空间，覆盖到栈上保存的 EAP / EBP 值
- IDA 开源平替 GHidra

### 栈相关的漏洞类型

#### 缺少边界检查的缓冲区溢出

```cpp
void dontDoThis(char* input) {
  char buf[16];
  strcpy(buf, input);
  printf("%s\n");
}

int main(int argc, char* argv[]) {
  dontDoThis(argv[1]);
  return 0;
}
```

#### 危险的栈上数据操作函数

- 输入读取函数
  - `gets()`
  - `scanf()`
- 字符串拷贝函数
  - `strcpy()`
  - `strcat()`
  - `sprintf()`

#### 栈溢出漏洞的技术手法

- **攻击目标.** 通过覆盖函数调用栈上的 *返回地址*，控制 IP 指针（`PC` 寄存器），以达到改变程序控制流的目的。
- **引发栈安全问题的语句.** 对栈上数据操作（主要是写操作）的不安全实现。

#### 攻击方式

- **Return-to-text.** 覆盖 EIP 跳转到代码段的指定区域。
- **Return-to-shell.** 注入 `execve("/bin/sh")` 等指令启动 `shell`。
  - 当下的主流操作系统已经有针对性防御。例如禁止执行栈上的数据段。
- **Return-to-LibC.** 覆盖 EIP，跳转到 C 标准库的某个函数的入口。这类函数通常涉及系统调用。
  - **Return-Oriented Programming.**
