# Index and Hashing

## Creation of Indices in SQL

- In SQL, we can create an index with `CREATE INDEX` command
- Indices can greatly speed up lookups, but will impose on updates
- Databases usually automatically creates indices on primary keys

## Basics

### Indices

An **index file** consists of records (called **index entries**) of the form `searchKey + pointer`

- The **search key** is an attribute or a set of attributes used to lookup records in a file
- Index files are typically much smaller than the original file

#### Basic Types of Indices

- **Ordered indices**: Search keys are stored in a sorted order
- **Hash indices**: Search keys are distributed uniformly across *buckets* using a *hash* function

#### Ordered Indices

- Index entries are stored sorted on the search key

##### Clustering Index and Nonclustering Index

- A **clustering index** (a.k.a. **primary index**) is an index whose search key has the same order as the sequential order of the file
- A **nonclustering index** (a.k.a. **secondary index**) is an index whose search key specifies an order different from the sequential order of the file

An **index-sequential file** is a sequential file ordered on the search key, with a clustering index on the search key

!!! note Note: Comparison between clustering and nonclustering indices
    - Clustering indices
      - Good locality
      - Substantial benefits when searching for records
      - Expensive to maintain on database update
        - Because the index must be in the same order as the sequential order of the relation
    - Nonclustering indices
      - Easier to update
      - But sequential scan using secondary indices can be slow on disk
        - Expensive ranged query

##### Dense and Sparse Index Files

- A **dense index** is an index whose record appears for each search key value in the file.
  - i.e., every possible value in the file has a corresponding search key in the index.
- A **sparse index** is an index that only contains records for *some* search-key values
  - Can be used records are sequentially ordered on a search-key
  - Consumes less space while still guarantees some lookup performance (although it is generally slower than a dense index)

!!! note Note: Tradeoff between dense and sparse indices
    For a clustering index, we can split the file into blocks, and create an index entry for every block in the file.

    For a non-clustering index, we can use a *multi-level index*: create a sparse index on top of dense index.

###### Secondary Dense Indices

- For secondary indices, they actually points to 'buckets' that contains pointers to all the actual records with the corresponding search-key value
- Secondary indices have to be dense, or otherwise the lookup cannot be done efficiently

### Multi-level Index

For a single-level index, if the index is too large to fit into memory, accessing the index becomes expensive

- To solve this problem, database systems treat index on disk as a sequential file, and create a sparse index on it
  - **outer index** refers to the sparse index of the basic index
  - **inner index** refers to the basic index file

### Index Update

We assume clustering index in this section

#### Deletion

- For a dense index, deletion of a search-key is similar to the file record deletion.
  - Assume the search key points to only a single value, then the search key can be directly deleted
  - Assume the search key points to multiple values, then the deletion of the search key depends on position of the record being deleted
- For a sparse index
  - If an entry for the search key exists in the index, the search key is deleted, and replaced with the next saerch-key value in the file
  - If the next search-key value is also in the index, then the search key can be directly deleted

#### Insertion

- For a dense index
  - If the search-key value does not exist in the index, insert it
    - Need to create new space for the new entry, in order to maintain the sequential order
- For a sparse index
  - Assume the index stores an entry for each block of the file, then no change needs to be made unless a new block is created
    - In the case where a new block is created, the first search-key value in the new block will be inserted into the index 

## B+ Tree

> The B+ Tree is a special multi-level index. It is a data structure that supports both efficient lookup and efficient sequential (incremental) access

### Definition of a B+ Tree

A B+ Tree is a tree with the following properties

- All paths from root to leaves are of the same length (balanced)
- Any node that is neither a root nor a leaf has between $\lceil n/2 \rceil$ and $n$ children (at least half-full)
- A leaf node has between $\lceil (n-1)/2 \rceil$ and $n-1$ values (at least half full)
- Special cases
  - If the root is not a leaf, it should have at least 2 children
  - If the root is a leaf (i.e., there are no other nodes in the tree), it can have between $0$ and $(n-1)$ values

### Structure of a B+ Tree

#### Typical Structure of a Node

A node with $n$ children have $n-1$ keys to guide lookups. The value of key $i$ is the minimum value of the $(i+1)$-th subtree

|  P1   |  K1   |  P2   |  K2   |  ...  | Pn-1  | Kn-1  |  Pn   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |

- Each $P$ is a pointer
  - Pointers at non-leaf nodes points to child nodes
  - Pointers at leaf nodes points to actual records (or buckets of records)
- Each $K$ is a search-key value
  - Search keys are ordered. $K_1 < K_2 < \cdots < K_n$

#### Non-leaf Nodes in B+ Trees

- Non-leaf nodes form a multi-level sparse index on leaf nodes

For a non-leaf node with $m$ pointers

- All search keys in the subtree pointed to by $P_1$ are less than $K_1$
- For $2 \le i \le n-1$, all search keys in the subtree pointed to by $P_i$ have values greater than or equal to $K_{i-1}$, and less than $K_i$. $K_i$ indicates the minimum value in subtree $i-1$.
- All search keys in the subtree pointed to by $P_n$ are greater than or equal to $K_{n-1}$

#### Leaves of B+ Trees

- Leaves of B+ trees store pointers pointing to file records
- For $i = 1,\dots,n-1$, pointer $P_i$ points to file record with search-key value $K_i$
  - If $L_i, L_j$ are two leaves with $i < j$, then the search-key values in $L_i$ are less than or equal to those of $L_j$.
- $P_n$ points to the next leaf node in the search-key order (for sequential access performance)

### Queries on B+ Trees

#### Single Query

Suppose we are querying value $v$

1. Start from root node
2. Do until reaches leaf nodes
   1. Find key $k$ such that $v \le k$
      1. If no such $k$ exists, then descend to the last non-null subtree
      2. If $ v = C.K_i$ then descend to $P_{i+1}$
      3. Else, desend to $P_{i}$
3. If some key $K_i$ at leaf node satisfies $K_i = v$, then return $C.P_i$
   1. Else, return null (query not hit)

#### Ranged Query

Find the lower bound, and then traverse along the linked list

#### Performance

For a file with $K$ search keys, the height of the tree is no more than $ \lceil \log_{\lceil n/2 \rceil}K \rceil $. Typically, 4 nodes are accessed in a lookup traversal from root to leaf

### Insertion

1. Find correct leaf $L$
2. Add new entry into leaf $L$
   - If $L$ has enough space (not full), then the insertion is done
   - Otherwise split $L$ into two smaller trees
     - Split in the middle, and copy the middle value to the parent tree as a key
3. If the parent is also full, then recursively split the parent, pushing (not copying) middle key to upper levels of the tree

### Deletion

1. Find correct leaf $L$
2. Remove the entry from $L$
   - If $L$ is still half-full after deletion, then the operation is done
   - Otherwise borrow elements from siblings
   - If siblings also do not have enough elements, then merge $L$ with its siblings
3. If the parent is also not-half-full after a merge, then recursively merge nodes, deleting entries pointing to the merged subtrees

### Complexity of B+ Trees

Time complexity for query, insertion and deletion of a $n$-nary B+ tree for $K$ search keys are all $\log_{\lceil n/2 \rceil}(K)$

## Hash Index
