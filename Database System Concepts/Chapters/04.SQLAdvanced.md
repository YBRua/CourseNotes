# Advanced SQL

## `JOIN` Expression

### `NATURAL JOIN`

`NATURAL JOIN` only considers those pairs of tuples with the same values on those attributes that appears in the schemas of both relations.

```sql
SELECT attr1, attr2, ..., attrn
FROM r1 NATURAL JOIN r2 NATURAL JOIN ... NATURAL JOIN rn
WHERE P
```

- Matches tuples with the same values fro all **common attributes**
- Retains only one copy of each common column

```sql
SELECT name, course_id
FROM students, takes
WHERE students.id = takes.id
```

is equivalent to

```sql
SELECT name, course_id
FROM students NATURAL JOIN takes
```

#### Notes on Using `NATURAL JOIN`

Note that `NATURAL JOIN` assumes **all** common attributes should be equal. In some cases this may lead to missing results.

!!! warning

    The following query lists all students along with the courses they have chosen. But it does not return the correct result. Because `dept_name` exists in both `student` and `course`, and this causes some results to be mistakenly filtered out by `NATURAL JOIN`

    ```sql
    SELECT name, title
    FROM student NATURAL JOIN takes NATURAL JOIN course;
    ```

    The correct query should be

    ```sql
    SELECT name, title
    FROM student NATURAL JOIN takes, course
    WHERE takes.course_id = course.course_id;
    ```

#### `JOIN...USING`

The `USING` clause is used to specify exactly which column of two relations should be equal.

```sql
SELECT name, title
(FROM student NATURAL JOIN takes) JOIN course USING (course_id);
```

#### `JOIN...ON`

The `ON` condition allows general predicates over the relations being joined. This expression is written like the `WHERE` clause except for the use of the keyword `ON` rather than `WHERE`

!!! info
    `ON` and `WHERE` behave similarly in many cases. Usually for better readability, `ON` is used for join conditions, while `WHERE` is used for filtering results.

    - In `OUTER JOIN`, `ON` and `WHERE` behaves differently

### `OUTER JOIN`

- An extension of the join operation that avoids loss of information
- Computes the join and then adds tuples from one relation that does not match tuples in the other relation to the result of the join operation using `NULL` values

!!! example
    As an motivating example, suppose we want to find the ID, name, dept_name and credits of all students,

    ```sql
    SELECT *
    FROM student NATURAL JOIN takes;
    ```

    However, this query omits those students who have not taken any courses.

There are three forms of outer join

1. The **left outer join** preserves tuples only in the relation named before (to the left of) the left outer join operation
2. The **right outer join** preserves tuples only in the relation named after (to the right of) the right outer join operation
3. The **full outer join** preserves tuples in both relations

`LazyPeopleException: Refer to slides or the textbook for examples.`

!!! info
    Consider two intersecting sets $A$ and $B$, out join not only includes $A \cap B$, but also preserves the remaining part of $A$ and/or $B$ depending on left/right/full mode.

### `INNER JOIN`

In constrast to `OUTER JOIN`, join operations that do not preserve nonmatched tuples are referred to as **inner join** operations. This is to distinguish them from outer join operations.

The keyword `INNER` is optional because a join operation without an `OUTER` keyword is by default inner join.

### Join Types and Join conditions

A join operation consists of a join type and a join condition

#### Join Types

|    Join Types    |
| :--------------: |
|    inner join    |
| left outer join  |
| right outer join |
| full outer join  |

#### Join Conditions

| Join Conditions  |
| :--------------: |
|     natural      |
| on \*predicate\* |
|  using (attrs)   |
|   \*nothing\*    |

Note that in sqlite3, a `NATURAL JOIN` cannot be used along with an `ON` or `USING` clause.

## Nested Subqueries

Queries can be nested. SQL provides a mechanism of nesting subqueries. A **subquery** is a select-from-where expression that is nested within another query.

- Commonly used in determining set membership, making set comparisons, and determining set cardinality.
- However, subqueries can be hard to optimize

### Using Subqueries

- A nested subquery can appear (almost) anywhere in a query, including
  - `SELECT` clause: Can be replaced with a subquery that generates a **single** column
  - `FROM` clause: Can be replaced with any valid subquery
  - `WHERE` clause: Can be replaced with an expression of the form `B <operation> (subquery)` where `B` is an attribute

### Types of Subqueries

A subquery can return

- A single atomic value (known as scalar-valued subqueries)
- A single tuple
- A relation

#### Scalar-Valued Subqueries

If a select-from-where clause returns an *atomic value*, it can be used a as a constant

- `v = (scalar-value-subqueries)`
- `(scalar-value-subqueries) > v`

Note that if an expected scalar-value subquery returns more than one value, an error will be raised.

### Subqueries in `WHERE`

#### Subquery Clauses

When subqueries is used in a `WHERE` clause, it can be used in conjunction with the following clauses

- `ALL`: Must satisfy expression for all rows in subquery
- `SOME` Must satisfy expression for at least one row in subquery
- `IN`: Equivalent to `=SOME()`, i.e. exists in the result of the subquery
- `EXISTS`: At least one row is returned
- `UNIQUE`: Subquery results have no duplicates

#### `ALL`

```sql
F comparator ALL(subquery)
```

Note that `!= ALL` is equivalent to `NOT IN`, but `= ALL` is not equivalent to `IN`

#### `SOME`

!!! example
    Find names of instructors with salary greater than that of some (at least one) instructor in the biology department

    ```sql
    SELECT name
    FROM instructor
    WHERE salary > SOME(
        SELECT salary
        FROM instructor
        WHERE dept_name = 'Biology'
    );
    ```

Note that `= SOME` is equivalent to `IN`, but `!= SOME` is not equivalent to `NOT IN`

#### `EXISTS`

The `EXISTS` returns `true` if the argument in the subquery is non-empty

!!! example

    Find all courses taught in both the fall 2017 and spring 2018

    ```sql
    SELECT course_id
    FROM section AS S
    WHERE semester = 'Fall' AND year = 2017 AND
    EXISTS (
        SELECT *
        FROM section AS T
        WHERE semester = 'Spring' AND year = 2018 AND S.course_id = T.course_id
    );
    ```

    Note that we used outer `S` in the inner subquery.

#### `UNIQUE`

Note that `UNIQUE` clause may not be supported in some DBMS

!!! example

    Find all courses that were offered at least once in 2017

    ```sql
    SELECT T.course_id
    FROM course AS T
    WHERE UNIQUE (
        SELECT R.course_id
        FROM section AS R
        WHERE T.course_id = R.course_id AND R.year = 2017
    );
    ```

### Subqueries in the FROM clause

SQL allows any valid subquery expression in the `FROM` clause.

### Constructing Temporary Relations with `WITH`

The `WITH` clause provides a way of defining a temporary relation whose definition is available *only to the query* in which the `WITH` clause occurs. (Behaves similarly to the assignment expression in the relational algebra)

!!! example

    Find all departments with the maximum budget

    ```sql
    WITH max_budget(value) AS (SELECT MAX(budget) FROM department)
        SELECT department.name
        FROM department, max_budget
        WHERE department.budget = max_budget.value;
    ```

## Views

The view mechanism hides data from the view of certain users.

### Creating a View

A view is defined using the `CREATE VIEW` statement which has the form

```sql
CREATE VIEW n AS (query)
```

Once a view is defined, it can be used to refer to the virtual relation that the view generates, in any other expressions

A view definition causes the saving of an query expression instead of evaluating it. When a query uses the view, the expression is then substituted into the query.

### Materialized Views

Certain DBMS allows view relations to be evaluated and *physically stored*. However, if the original relation is updated, the materialized view becomes out of date, and requires maintenance.

## Update with SQL

### Deletion

```sql
DELETE FROM /* relations */ WHERE /* conditions */
```

### Insertion

```sql
INSERT INTO /* relation [attr names] */
    VALUES /* tuple */;
```

We can also perform insertion based on the result of a query

```sql
INSERT INTO instructor
    SELECT ID, name, dept_name, 18000
    FROM student
    WHERE dept_name = 'Music' AND total_cred > 144;
```

!!! warning

    Be ware of infinitely recursive insertions, such as

    ```sql
    INSERT INTO table1 SELECT * FROM table1
    ```

### Updates

```sql
UPDATE /* relation */
    SET /* update value */
    WHERE /* condition */
```

!!! example

    Examples using `UPDATE`

    ```sql
    UPDATE instructor
        SET salary = salary * 1.05;
    ```

    ```sql
    UPDATE instructor
        SET salary = salary * 1.05
        WHERE salary < 70000;
    ```

#### `CASE` Expressions

Suppose we want to increase of instructors whose salary is over $100k by 3%, and all others by 5%

```sql
UPDATE instructor
    SET salary = salary * 1.03
    WHERE salary > 100000;
UPDATE instructor
    SET salary = salary * 1.05
    WHERE salary < 100000;
```

However, the order is important.

Conditional update can be done better using the `CASE` expression

```sql
UPDATE instructor
    SET salary = 
        CASE
            WHEN salary <= 100000 THEN salary * 1.05
            /* more WHEN ... THEN ... here if there are other branches */
            ELSE salary * 1.03
        END
```

## Integrity Constraints

**Integrity Constraints** ensure that changes made to the database by authorized users do not result in loss of data consistency.

### Not-Null Constraints

The **not-null** constraint prohibits the insertion of null values for the attribute. For example, if an attribute is used as the primary key, then it cannot be null.

!!!example
    Specifying *name* and *budget* to be not null

    ```sql
    name VARCHAR(20) NOT NULL
    budget NUMERIC(12, 2) NOT NULL
    ```

### Unique Constraints

The **unique** constraint specifies that a set of attributes forms a primary key: no two tuples in the relation can be equal on all the listed attributes.

```sql
UNIQUE(attr1, attr2 /*, ... */, attrn)
```

However, candidates can be null, unless they are explicitly constrained by a not-null constraint.

### Check Clause

When applied to a relation declaration, the **check** clause specifies a predicate $P$ that must be satisfied by every tuple in the relation.

- The check clause in effect creates a type system
- A check clause is satisfied *if is not false*, which means null values also pass the check (since they returns `unknown`)

!!!example
    Using check to similate an enumerated type `semester`

    ```sql
    CREATE TABLE section (
        course_id       VARCHAR(8),
        sec_id          VARCHAR(8),
        semester        VARCHAR(6),
        year            NUMERIC(4, 0),
        building        VARCHAR(15),
        room_number     VARCHAR(7),
        time_slot_id    VARCHAR(4),
        primary key (course_id, sec_id, semester, year),
        CHECK (semester IN ('Spring', 'Fall', 'Summer'))
    )
    ```

!!!example
    The check clause can also be used as part of the declaration of an attribute.

    ```sql
    budget  NUMERIC(12, 2)  CHECK(budget > 0)
    ```

### Referential Integrity

The **referential integrity constraint** ensures a value that appears in one relation (*referencing relation*) for a given set of attributes also appears for a set of attributes in another relation (*referenced relation*)

The **foreign keys** are a form of referential integrity constraint.

!!!example
    Specifying for each tuple, the departname name specified in the tuple must exist in the department relation

    ```sql
    FOREIGN KEY (dept_name) REFERENCES department
    ```

!!!example
    By default, SQL references the primary-key attributes of the referenced table, but it can also be specified explicitly.

    ```sql
    FOREIGN KEY (dept_name) REFERENCES department(dept_name)
    ```

#### Cascading

When a referential-integrity constraint is violated, the default action is to reject the query. However, several other actions can be taken.

**cascade** specifies that if a change of tuple in the *referenced* relation would result in a violation of the constraint, the system does not reject the change, instead it takes actions in the *referencing* relation to maintain the constraint

!!!example
    The **on delete cascade** clause specifies that if a deletion in the referenced relation (*department*) breaks the constraint, the system should delete all tuples in the referencing relation (*course*) that referenced the deleted tuple.

    ```sql
    FOREIGN KEY (dept_name) REFERENCES department
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    ```

    Similarly, by using **on update cascade**, the system automatically updates referencing tuples in *course* when a tuple in *department* is updated.

!!!note
    In addition to cascade, other actions can also be used, such as `SET NULL` and `SET DEFAULT`

## Others
