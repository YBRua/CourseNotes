# 同步原语

> “一个人要怀胎十月才能生一个宝宝”
> “那十个人呢”

## 竞争条件 Race Condition

- 竞争条件
  - 当两个或以上的线程（也可能是进程）同时对共享的数据进行操作，且其中至少有一个写操作
  - 对该共享数据的操作结果依赖于这些线程（或进程）的执行顺序

## 同步原语

### 同步原语 Synchronization Primitives

同步原语是一个由平台（如操作系统）提供的用于帮助开发者实现线程之间同步的软件工具

### 生产者消费者问题

#### 模型

- 生产者生产新的数据
- 消费者不断地拿取数据进行处理
- 有一个有限长度的 `buffer` 用于给生产者和消费者共享数据
  - 要求数据能够有效、正确地在生产者与消费者之间传递
  - `buffer` 满时，生产者应暂停放入数据，避免数据被覆盖
  - `buffer` 空时，消费者应暂停读取数据，避免读到无效数据

```js
// producer
while (prodCnt - consCnt == BUFFER_SIZE)
  ; // wait until buffer is not full
buffer[prodCnt % BUFFER_SIZE];
prodCnt = prodCnt + 1;

// consumer
while (prodCnt == consCnt)
  ; // wait until buffer is not empty
item = buffer[consCnt % BUFFER_SIZE];
consCnt = consCnt + 1;

/*
              Producer
              │
┌───┬───┬───┬─▼─┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │
└───┴─▲─┴───┴───┴───┘
      │
      Consumer
 */
```

#### 单生产者、单消费者

上述代码本身已经可以实现单生产者、单消费者之间的协调。

#### 多生产者

在有多个生产者时，上述代码将会出现问题。如果两个生产者同时尝试将数据写入 `buffer` 的同一个槽位，将会导致某个数据被覆盖，造成更新丢失。

### 临界区抽象 Critical Section

在类似上述多生产者的场景下，需要保证同一时刻只有一个生产者能够对共享的缓存区进行操作

```mermaid
graph LR
    申请进入临界区-->临界区部分
    临界区部分-->通知退出临界区
    通知退出临界区-->其他部分
```

- **临界区**：保证互斥访问共享资源的代码区域
- 即使在单核情境下，临界区问题也可能存在
  - 因为抢占式调度可能在任何时候打断任务执行
  - 正在临界区的线程可能被打断，然后调度到另一个线程进入临界区，导致两个线程同时处在临界区

#### 三个要求

- 互斥访问
  - 在同一时刻，至多只有一个线程可以进入临界区访问共享数据
- 优先等待
  - 当一个线程申请进入临界区后，必须在有限时间内获得进入临界区的许可，而不能无限等待
- 空闲让进
  - 当没有线程在临界区中时，必须在申请进入临界区的线程中选择一个进入临界区，保证临界区的进展

### 互斥锁 Mutual Exclusive Lock Mutex

- 可以保证同一时刻只有一个线程能够拿到锁

#### 接口

- `lock` :lock:
  - 若当前没有其他线程拿到锁，则拿到锁并进入临界区执行
  - 否则不断等待其他线程释放锁 (busy loop)
- `unlock`
  - 释放锁

#### 基于互斥锁的临界区实现

```js
while (prodCnt - consCnt == BUFFER_SIZE)
    ;

lock(&buffer_lock);
/* critical zone */
buffer[bufCnt % BUFFER_SIZE] = item;
bufCnt = bufCnt + 1;
/* critical zone */
unlock(&buffer_lock);

prodCnt = prodCnt + 1; // assumes atomic operation here
```

- `lock` 阻塞当前线程，直到成功上锁，然后进入临界区
- `unlock` 释放锁

#### POSIX Thread 提供的锁接口

- `pthread_mutex_lock(&lock)` 锁
- `pthread_mutex_unlock(&unlock)` 解锁

### 条件变量

> 线程等待锁时使用busy loop，如何避免无意义的等待？
> > “这显然不符合我们碳中和、碳达峰的要求”

条件变量利用睡眠/唤醒机制，避免无意义的等待

- 当前线程等待的某一条件不能被满足时，当前线程将停止使用CPU并被挂起，之后不会被调度器调度
  - 进而避免在CPU上忙等，节省CPU资源
- 等待的条件满足时，其他线程会唤起被挂起的线程，该线程于是可以被调度执行

#### 接口

- 等待
  - `void cond_wait(struct cond *cond, struct lock *mutex)`
  - 放入条件变量的等待队列
  - 阻塞自己，释放锁，调度器可以调度到其他线程
  - 被唤醒后，重新获取锁
- 唤醒
  - `void cond_signal(struct cond *cond)`
  - 检查等待队列是否为空
  - 如果有等待中的线程，则从队列中移出一个线程并将其唤醒
  - `void cond_broadcast(struct cond *cond)`
  - 功能类似，但是会唤起所有等待该条件变量的线程

#### 使用条件变量实现的共享缓存区

```js
// producer
lock(empty_cnt_lock);
empty_slot ++;
cond_signal(empty_cond);
unlock(empty_cnt_lock);

// consumer
lock(empty_cnt_lock);
while (empty_slot == 0) { // notice the while loop here
  cond_wait(empty_cond, emtpy_cnt_lock);
}
empty_slot --;
unlock(empty_cnt_lock)
```

一些QA

##### `while` 循环

- 理论上消费者被唤起时，条件一定得到满足（即`buffer`非空）为什么需要一个额外的 `while` 循环？
  - 考虑多核、多消费者的情况，假设条件变量得到满足，消费者1刚刚被唤起
  - 此时消费者2进入消费者流程，由于此时 `buffer` 里有一个东西，消费者2不会睡眠而是直接进入临界区消耗掉 `buffer` 中的物品，`buffer` 又空了
  - 如果没有 `while` 循环，调度到消费者1时，消费者1将尝试从 `buffer` 中取出一个物品，但是此时 `buffer` 已经空了

##### 是否有必要每次都调用 `cond_signal`？

- 直觉上只有 `empty_slot == 0` 时才会有消费者在等待，也许可以只在这个时候调用 `cond_signal`？
  - 可惜不行。
  - 因为可能有多个消费者在等待，此时还可能有多个生产者到达，如果只在 `empty_slot == 0` 时调用一次 `cond_signal`，则只会唤起其中一个消费者，其他消费者将与世长辞。
  - 一种workaround是使用 `cond_broadcast`。但是如果只新产生了一个 `item`，则只有一个消费者能拿到，其他消费者检查之后会重新阻塞自己，从而浪费一些CPU资源。这种情况在消费者较多、生产者较少的场景中尤为严重。称为**惊群效应**。

##### `cond_signal` 能不能放在临界区外

- 有时候可以。但是不建议。否则可能造成消费者无限等待。在某些代码实现下，可能会产生如下执行顺序
  - 消费者到达，发现没有空余 `item`，进入while循环之后被调度走
  - 生产者产生一个新的 `item`，调用 `cond_signal`，但是没有线程被唤起，因为没有线程在等待
  - 消费者重新被调度到，执行下一行 `cond_wait`，此时虽然有一个新的 `item`，但是消费者并没有收到通知。寄。

### 信号量 Semaphore

- 另一种同步原语，便于在多个线程之间管理资源
  - 信号量用于协调（阻塞/放行）多个线程共享有限数量的共享资源
  - 语义上，信号量的值记录了**当前可用资源的数量**
    - 与互斥锁不同，互斥锁的值本身不含有语义信息
- 信号量维护当前可用资源的数量，同时保证有且只有一个线程在使用该共享资源

#### 生产者消费者的另一种实现

```js
// producer
while (true) {
  new_msg = produce_new_msg();

  lock(empty_slot_lock);
  while (empty_slot == 0) {
    cond_wait(empty_cond, empty_slot_lock);
  }
  empty_slot --;
  unlock(empty_slot_lock);

  atomic_buffer_add(new_msg);

  lock(filled_slot_lock);
  filled_slot ++;
  cond_signal(filled_cond);
  unlock(filled_slot_lock);
}

// consumer
while (true) {
  lock(filled_slot_lock);
  while (filled_slot == 0) {
    cond_wait(filled_cond, filled_slot_lock)
  }
  filled_slot --;
  unlock(filled_slot_lock);

  cur_msg = atomic_buffer_remove();

  lock(empty_slot_lock);
  empty_slot ++;
  cond_signal(empty_cond);
  unlock(empty_slot_lock);
  
  handle_msg(cur_msg);
}
```

#### 接口

- p操作：消耗资源
  - `void sem_wait(sem_t *sem)`
  - 荷兰语 passeren (pass)

```cpp
// semantic of p
void wait(int *S) {
  while (*S <= 0) {
    // busy loop
  }
  *S = *S - 1;
}
```

- v操作：增加资源
  - `void sem_signal(sem_t *sem)`
  - 荷兰语 verhoog (increment)

```cpp
// semantic of v
void signal(int *S) {
  *S = *S + 1;
}
```

- 此外，信号量还支持对信号量初始值进行初始化
  - 初始化的值表明初始共享资源的数量

#### 基于信号量的生产者消费者实现

```js
void producer() {
  new_msg = produce_new();
  wait(empty_slot_sem); // wait for and consume empty slots
  buffer_add(new_msg);
  signal(filled_slot_sem); // increment filled slots
}

void consumer() {
  wait(filled_slot_sem); // wait for and consume filled slots
  cur_msg = buffer_remove()
  signal(empty_slot_sem); // increment empty slots
  handle_msg(cur_msg);
}
```

#### 二元信号量与计数信号量

- 初始化信号量时，可以指定资源数量
  - `void sem_init(sem_t *sem, int init_cnt)`
- 当初始化数量 `init_cnt` 为1，则为**二元信号量**
  - 计数器只有0和1两个值
  - 同一时刻最多只有一个线程可以拿到该资源
- 当初始化数量大于1时，则为**计数信号量**
  - 同一时刻可能有多个线程可以拿到该资源

### 读写锁

- 如果使用一般的互斥锁实现读写操作，则一个线程在读的时候，其他线程都不能读
  - 但是读者之间并不互斥
    - 因为至少需要一个写操作才会发生竞争
- 读写锁区分读者和写者，允许读者之间并行
  - 读者和写者之间互斥
  - 写者和写者之间互斥

#### 接口

- `lock_reader()` `unlock_reader()`
  - 读者在临界区时，不允许写者进入临界区
- `lock_writer()` `unlock_writer()`
  - 写者在临界区时，不允许读者或其他写者进入临界区

#### 读写协调

- 如果有很多读者一直轮流读取数据，则写者可能被饿死
  - 解决方案之一是，在有写者等待时，读者临界区“只出不进”

### 同步原语之间的比较

#### 互斥锁、条件变量、信号量

- 互斥锁与二元信号量功能类似，但是抽象不同
  - 互斥锁有拥有者的概念，一般同一个线程拿锁、放锁
  - 信号量没有锁的拥有者这样的概念，注重资源协调，一般一个线程signal，一个线程wait
  - 但是两者在功能上一般可以互相替代
- 条件变量用于解决睡眠、唤醒的问题，而且需要搭配互斥锁使用
  - 调用条件变量的接口时需要提供一个 `lock`

#### 互斥锁、读写锁

- 接口不同
- 针对场景不同
- 读写锁在读多、写少的场景中可以显著提高读者并行度，进而提高性能
- 只使用写者锁时，则与互斥锁的语义基本相同

## 死锁

> “一个人拿着A锁等B锁，另一个人拿着B锁等A锁”

### 产生原因

- 互斥访问
  - 同一时刻只有一个线程能访问某个资源
  - 在有互斥访问的前提下，才会出现某个线程在等待
- 持有并等待
  - 线程持有一些资源，并等待另一部分资源
  - 等待期间，线程不会中途释放锁
- 资源非抢占
  - 一旦一个资源被持有，除非持有者主动放弃，否则其他竞争者都无法得到这个资源
- 循环等待
  - 一个等另一个一个等另一个一个等另一个一个等另一个（x
  - 死锁出现的关键

> 虽然死锁带着“锁”字，但是不一定是只有互斥锁才会造成死锁，只要满足上述四个条件，都有可能产生死锁

- 除了多线程互相阻塞导致的死锁外，还有一种造成死锁的情况
  - 例如在中断中使用了互斥锁，然后在拿着锁的时候又触发了中断
  - 递归调用中也会有类似的情况
  - 这类情况可以通过**可重入锁**解决，即判断持有锁的线程是否为自己
  - 或者是加锁时关中断、放锁时开中断解决

### 应对策略

#### 死锁检测与恢复

> “出了问题再处理”

- 建立资源分配图
  - `资源 ---> 线程` 表示线程持有资源
  - `线程 -.-> 资源` 表示线程等待资源
- 如果资源分配图上有环，则表示出现循环等待
  - kill掉循环中的所有线程
  - kill一个线程，检查是否还有环，持续到分配图中不存在环
  - 全部回滚到之前的某个状态，然后~~祈祷~~检查回滚后重新运行是否还是遇到死锁
    - 死锁往往是由于特定的逆天调度和触发时机导致，回滚后再次运行时通常能work
- 由于建图找环开销较大，通常操作系统不会很勤快地频繁运行死锁检测
  - 通常采用定时检测，或者超时等待检测

#### 死锁预防

##### 避免互斥访问

- 避免直接操作共享变量
- 通过代理线程操作
  - 只有代理线程能够访问共享资源
  - 其他线程发送修改请求，由代理线程统一执行

不过大部分应用不能很方便地改成这种模式，而且维护代理线程也会带来开销

##### 不允许持有并等待

- 每个线程一次性申请自己需要的所有:lock:
- 如果成功，则继续执行
- 如果失败，则释放所有成功获得的:lock:，等待并重新尝试申请所有需要的:lock:

###### 活锁

- 线程A和线程B都需要锁M和锁N
  - A申请到了M，B申请到了N
  - A申请N失败，B申请M失败
  - A和B释放各自拿到的锁，重新尝试申请M和N
  - A申请到了M，B申请到了N
  - A申请N失败，B申请M失败
  - 寄！
- 但是活锁有机会自行恢复

##### 资源允许抢占

- 允许根据某些策略让一个线程抢占另一个线程持有的锁
  - 线程A抢占线程B的锁后，需要让线程B正确回滚到拿到锁之前的状态

##### 打破循环等待

- 按照特定顺序获取资源
- 对所有资源进行编号
- 让所有线程按资源编号顺序申请锁
  - 不会出现拿着A等B、拿着B等A
  - 因为所有线程都应该先拿A再拿B
  - 如果因为控制流原因，出现了先拿到了B又需要拿A的情况，则应先释放B

#### 死锁避免：银行家算法

系统在运行时跟踪资源分配过程来避免死锁。任意线程需要资源需要向系统申请，系统根据执行状态判断是否能够分配资源

##### 安全状态与非安全状态

- 安全状态
  - 存在至少一个安全序列，只要系统按照该序列调度线程，即可避免资源不足
  - 只要处在安全状态，系统在处理线程分配资源的申请时就能找到一条安全序列，并且可以按照这条安全序列继续调度
- 非安全状态
  - 不存在安全序列
  - 非安全状态不一定导致死锁
    - 如果运行过程中某个线程释放了一些资源，或者不需要它申请的所有资源就可以结束运行，则可能不会导致死锁
    - 如果所有线程都不释放资源，且都需要它申请的所有资源，则大寄特寄
- 死锁避免算法要求每次分配资源后，系统都处于安全状态，否则将拒绝分配资源

##### 银行家算法

> “过于经典以至于没有人用。”
> “但是在大纲里所以我们还是要教。”

- 所有线程获取锁需要经过管理者同意
- 管理者预演是否会造成死锁
  - 如果会，则阻塞线程，下次再同意
  - 否则正常给线程分配资源

银行家算法啊需要维护四个数据结构。假设有 `M` 个资源、`N` 个线程。

- `available[M]` 记录全局可利用资源，初始化为系统拥有的 `M` 类资源的总量
- `max[N][M]` 线程 `N` 对资源 `M` 的最大需求量
- `allocation[N][M]` 已经分配给线程 `N` 的资源 `M` 的数量
- `need[N][M]` 线程 `N` 对资源 `M` 还需要的数量

此外，还需要保证以下前提

- 系统中的供给关系固定。整个系统中各个资源的总量，以及各个线程对各个资源的需求量，都需要是固定的。
- 任意线程对资源的最大需求量不能超过该资源的总量。
- 对任意线程、任意资源，该线程已分配的资源和还需要的数量之和不能超过该线程对该资源的最大需求量
- 线程获得了需要的资源之后，能够在有限时间内完成工作，并释放它的资源

银行家算法的安全性检查如下

1. 创建 `available_sim`，初始值与 `available` 一致，用于记录接下来的模拟中系统资源的数量
2. 找到当前系统剩余资源能够满足的一个线程
   - 要求存在线程 `x`，对每一类资源 `m` 都有 `available_sim[m] >= need[x][m]`
   - 如果找不到满足条件的线程，则系统处于不安全状态
3. 假设将资源全部分配给它，且它执行完毕后会释放所有资源
   - 标记线程执行结束
   - 然后对每一类资源 `m`，执行 `available_sim[m] += allocation[x][m]`
4. 重复前两步，直到所有线程模拟执行完毕
