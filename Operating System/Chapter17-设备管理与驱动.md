# 设备管理与驱动

## 标准IO协议

### 设备规范

设备需要提供一些对外接口，

- 状态寄存器
- 地址寄存器
- 数据寄存器
- 命令寄存器

除此之外，设备还会有一些不暴露在外的内部设备（微控制器、内部存储或其他硬件芯片）

### 轮询IO流程

- 从CPU的视角
  - 等待直到设备空闲
    - 轮询状态寄存器，确定设备是否空闲
  - 将数据和地址写入设备的对应寄存器
  - 将命令写入命令寄存器
  - 等待设备完成工作
    - 轮询状态寄存器，确定设备是否完成任务
- 从设备的视角
  - 轮询命令寄存器
  - 如果有新命令，则修改状态寄存器，开始工作
  - 完成命令后恢复到等待状态

### 基于中断的IO

- OS向设备发送一个请求，随后让发起IO的进程睡眠（该进程将处于 `WAITING` 状态）
  - 此时CPU可以切换到其他进程
- 设备完成IO后，触发IO中断
- CPU跳转到中断处理程序
- 内核态的中断处理程序负责响应设备中断
  - 例如读取设备数据或返回的状态码，进而唤醒等待IO的进程
- 这种中断只适用于低速设备（例如键盘），用于在等待设备时提高CPU利用率

#### 中断造成的活锁

- 如果IO设备速度较快，例如工作在极佳网络环境下的网卡，导致IO设备频繁向CPU发送中断时，操作系统可能进入活锁
  - CPU忙于响应设备的中断，无法调度用户进程或处理中断发来的数据
  - “看上去它很忙，但是实际上什么都没干。我不知道同学们平时会不会有这种状态”

#### 中断合并 Interrupt Coalescing

- 基于“一个中断到来后，很可能短时间内会有另一个中断”的直觉
- 因此设备发送中断前会先等待一段时间，如果等待期间有新的中断，则合并中断
  - 代价是过长的等待时间可能导致高时延

### 中断与轮询结合的IO

- 默认使用中断
- 网络中断发生后，使用轮询处理后续到达的网络包
  - 网络包通常是短时间内来一大堆
- 如果没有更多中断，或轮询中断超过时间限制，则回到中断模式
- 在Linux网络驱动中称为NAPI（New API）

## 直接内存访问 Direct Memory Access DMA

### 传统的IO流程

- CPU从设备读取数据，存入CPU的寄存器
- CPU将数据从寄存器转入内存
- 低效
- be like
  - 用勺子从一个游泳池往另一个游泳池舀水.gif

### DMA

- CPU向磁盘控制器发送“读”请求
  - 给定要读的地址和目标内存地址
  - 一次读取一块数据
- 磁盘控制器直接将数据写入内存
  - No more CPU involvement

#### 优势

- 减轻CPU负担
- 减少传输次数
- 更好的支持“长消息”
- 分摊总线协议开销

#### 缺陷

- 不适合单次小批量读取数据

## 设备交互

### PIO

- 在x86上，使用 `IN` `OUT` 指令
  - `IN` 是读入CPU，`OUT` 是从CPU写出
- 需要以内核态特权模式执行

### 内存映射 IO

- 将设备寄存器映射到内存地址空间
  - 内存地址被IO设备位置信息重载
- 使用访存的 `LOAD` `STORE` 指令操作设备
- 可以以非特权模式（用户态）执行
- 配置页表时，映射到设备的内存地址需要设置为 `NON_CACHABLE`
  - 否则CPU可能会直接读cache，但设备寄存器的数据已经被更新了

## 硬件总线

### 硬件总线的特点

- 物理上是一组电线
  - 有地址总线、数据总线、控制总线等
  - 将IO设备连接在一起
- 广播特性
  - 每个模块都能接收到总线上的数据
  - 通过地址总线指定预期的接收方
- 仲裁协议
  - 决定哪些设备可以在什么时候使用总线

### 总线事务 Transaction

## IO子系统

### IO子系统的意义

IO子系统主要处理兼容性、容错性等问题

- 数以千计的设备类型
  - 需要标准化的接口
- 设备的不可靠性
  - 传输介质可能失效或发生错误
- 设备的不可预测性和慢速
  - 在不清楚设备具体速度和性能表现的前提下管理设备

### 三类设备接口

Linux提供三类常见的设备接口：字符设备、块设备、网络设备。所有设备在上层被文件系统接口统一，可以使用 `open` `read` `write` 等文件系统接口操作。

#### 字符设备

“流式设备”，数据流输入CPU

#### 块设备

具有空间概念，可以往前或往后读。硬盘、光盘等。具有Buffer-Cache概念：写Buffer、读Cache

#### 网络设备
