# 设备管理与驱动

## 标准IO协议

### 设备规范

设备需要提供一些对外接口，

- 状态寄存器
- 地址寄存器
- 数据寄存器
- 命令寄存器

除此之外，设备还会有一些不暴露在外的内部设备（微控制器、内部存储或其他硬件芯片）

### 轮询IO流程

- 从CPU的视角
  - 等待直到设备空闲
    - 轮询状态寄存器，确定设备是否空闲
  - 将数据和地址写入设备的对应寄存器
  - 将命令写入命令寄存器
  - 等待设备完成工作
    - 轮询状态寄存器，确定设备是否完成任务
- 从设备的视角
  - 轮询命令寄存器
  - 如果有新命令，则修改状态寄存器，开始工作
  - 完成命令后恢复到等待状态

### 基于中断的IO

- OS向设备发送一个请求，随后让发起IO的进程睡眠（该进程将处于 `WAITING` 状态）
  - 此时CPU可以切换到其他进程
- 设备完成IO后，触发IO中断
- CPU跳转到中断处理程序
- 内核态的中断处理程序负责响应设备中断
  - 例如读取设备数据或返回的状态码，进而唤醒等待IO的进程
- 这种中断只适用于低速设备（例如键盘），用于在等待设备时提高CPU利用率

#### 中断造成的活锁

- 如果IO设备速度较快，例如工作在极佳网络环境下的网卡，导致IO设备频繁向CPU发送中断时，操作系统可能进入活锁
  - CPU忙于响应设备的中断，无法调度用户进程或处理中断发来的数据
  - “看上去它很忙，但是实际上什么都没干。我不知道同学们平时会不会有这种状态”

#### 中断合并 Interrupt Coalescing

- 基于“一个中断到来后，很可能短时间内会有另一个中断”的直觉
- 因此设备发送中断前会先等待一段时间，如果等待期间有新的中断，则合并中断
  - 代价是过长的等待时间可能导致高时延

### 中断与轮询结合的IO

- 默认使用中断
- 网络中断发生后，使用轮询处理后续到达的网络包
  - 网络包通常是短时间内来一大堆
- 如果没有更多中断，或轮询中断超过时间限制，则回到中断模式
- 在Linux网络驱动中称为NAPI（New API）

## 直接内存访问 Direct Memory Access DMA

### 传统的IO流程

- CPU从设备读取数据，存入CPU的寄存器
- CPU将数据从寄存器转入内存
- 低效
- be like
  - 用勺子从一个游泳池往另一个游泳池舀水.gif

### DMA

- CPU向磁盘控制器发送“读”请求
  - 给定要读的地址和目标内存地址
  - 一次读取一块数据
- 磁盘控制器直接将数据写入内存
  - No more CPU involvement

#### 优势

- 减轻CPU负担
- 减少传输次数
  - 从两次传输减少到一次
- 更好的支持“长消息”
- 分摊总线协议开销

#### 缺陷

- 不适合单次小批量读取数据

## 设备交互

### PIO

- 在x86上，使用 `IN` `OUT` 指令
  - `IN` 是读入CPU，`OUT` 是从CPU写出
- 需要以内核态特权模式执行

### 内存映射 IO

- 将设备寄存器映射到内存地址空间
  - 内存地址被IO设备位置信息重载
- 使用访存的 `LOAD` `STORE` 指令操作设备
- 可以以非特权模式（用户态）执行
- 配置页表时，映射到设备的内存地址需要设置为 `NON_CACHABLE`
  - 否则CPU可能会直接读cache，但设备寄存器的数据已经被更新了

!!!info MMIO地址应该使用 `volatile` 关键字
    否则可能会被编译器优化掉。

## 硬件总线

### 硬件总线的特点

- 物理上是一组电线
  - 有地址总线、数据总线、控制总线等
  - 将IO设备连接在一起
- 广播特性
  - 每个模块都能接收到总线上的数据
  - 通过地址总线指定预期的接收方
- 仲裁协议
  - 决定哪些设备可以在什么时候使用总线

### 总线事务 Transaction

1. 源模块获取总线的使用权
   - 总线的使用具有排他性
2. 源模块将目标模块的地址写到总线
3. 源模块发送READY信号，广播提醒其他模块
4. 目标模块在拷贝完数据后，发送ACK信号
   - 如果采用同步模式，则无需READY和ACK，只要在每个时钟周期检查即可
5. 源模块释放总线

### 同步与异步

- 同步数据传输
  - 源和目标根据共享的时钟进行操作
    - 例如DDR内存
- 异步数据传输
  - 源和目标借助显式信号进行协作

## IO子系统

### IO子系统的意义

IO子系统主要处理兼容性、容错性等问题

- 数以千计的设备类型
  - 需要标准化的接口
- 设备的不可靠性
  - 传输介质可能失效或发生错误
- 设备的不可预测性和慢速
  - 在不清楚设备具体速度和性能表现的前提下管理设备
  - 不同设备的处理性能差异极大，IO子系统需要能够处理这类差异
    - 对高速设备，需要最小化使用开销
    - 对慢速设备，需要避免浪费CPU时间在盲目等待

### IO子系统的目标

- 对各种设备提供统一的接口
- 提供IO硬件的抽象层，管理硬件资源，隐藏硬件细节

### 三类设备接口

Linux提供三类常见的设备接口：字符设备、块设备、网络设备。所有设备在上层被文件系统接口统一，可以使用 `open` `read` `write` 等文件系统接口操作。

#### 字符设备

“流式设备”，数据流输入CPU

- 例如鼠标、键盘、串口、部分USB
  - 串行访问，每次一个字符
- 通常使用文件系统接口进行交互

#### 块设备

具有空间概念，可以往前或往后读。硬盘、光盘等。具有Buffer-Cache概念：写Buffer、读Cache

- 例如磁盘、磁带、DVD
- 统一的、以块为粒度的访问接口
- 提供原始的IO接口，也支持以文件形式访问
- 允许以内存映射的方式访问文件内容

#### 网络设备

- 例如网卡、无线网络、蓝牙
- 不同于块设备、字符设备，网络设备有自己的接口
  - 提供特殊的网络接口，支持各类网络协议
  - 负责网络包收发

### 设备驱动

- 提供特定的代码，和硬件设备直接交互
  - 要求提供标准的文件系统接口
  - 内核的IO子系统可以和内核中的不同驱动交互
  - 可以借助 `ioctl()` 系统调用进行设备的相关配置或者解析自定义的功能
- Linux的设备驱动通常分为两部分
  - 上半部：迅速处理，此时中断关闭，没有嵌套
  - 下半部：延后处理，此时中断打开，可能发生嵌套

## IOMMU

- IOMMU为IO设备做地址翻译，避免设备直接使用物理地址访问内存
  - 设备使用的地址由IOMMU翻译为实际的物理地址
  - 广泛应用于虚拟机场景中
    - 允许虚拟机独占某个设备
- 提高安全性，并提供额外的抽象