# 进程管理

## 进程生命周期管理

> 进程管理，即管理进程的生命周期

- 进程自创建到终止可能经理多个过程
  - 称为进程**状态**
- 不同的系统调用或事件会影响进程的状态

### 进程状态

- 新生 New
  - 刚被创建
  - 尚未完成初始化，因此不能被调度执行
  - 初始化完成后迁移到就绪状态
- 就绪 Ready
  - 可以被调度执行，但是未被调度器选择
  - 在被调度到后将会迁移到运行状态
- 运行 Running
  - 正在CPU上运行
  - 调用 `exit` 将会迁移到僵尸状态并最终终止
  - 调用 `fork` 将会回到就绪状态等待再次被调度
  - 调用 `wait` 将会进入阻塞状态知道子进程终止
- 阻塞 Blocked
  - 等待某个事件，暂时无法被调度
  - 等待的事件完成后，将会进入就绪状态
- 僵尸 Zombie
  - 已退出，资源未完全回收
  - 完全回收后将到达终止状态
- 终止 Terminated
  - 已退出，且资源被完全回收

### 进程控制块 PCB

```cpp
// ChCore中的PCB的简化实现
struct process {
  // context
  struct process_ctx *process_ctx;
  // vm space
  struct vmspace *vm_space;
}
```

- 每个进程对应一个元数据，称为进程控制块
  - 是OS记录的进程元数据，对进程本身不可见
  - 存储在内核态
  - “进程的户口本”
  - “我到现在都没看到过我的档案，因为我是用户态的”
- PCB中需要保存的信息
  - 虚拟地址空间 `vmspace`：与虚拟地址相关的内容
    - VMA
    - 页表基地址
  - 执行上下文 `process_ctx`
    - `PC` 寄存器
    - `SP` 寄存器
    - 还有些别的

### 创建进程：`fork`

- Shell调用 `fork`，陷入内核态，触发相关处理函数
- 内核创建新的PCB，用于维护新进程的运行时状态和持有的资源
- 将原有PCB的内容拷贝到新的PCB中（[深拷贝](#深拷贝)）
  - 不能只复制指针，否则会造成错误共享
- 准备执行子进程
  - 等待调度器调度父进程或子进程

#### 深拷贝

- 浅拷贝
  - 只复制指针
  - 不复制指针指向的数据结构
- 深拷贝
  - 复制完整的数据结构
  - 不复制指针（因为指针是新开的，指向新的数据结构）

#### 第一个进程

- 第一个进程 `root` 通常由内核创建
  - 同样需要创建PCB
  - 由于没有可拷贝的PCB，所有内容需要手动初始化
- `root` 是所有其他进程的祖先
- `root` 可协助完成进程的回收
- 在系统初始化时会创建 `root`，然后才会进入用户态，开始执行第一行用户态应用程序的代码

#### Fork完成后

- `fork` 只能生成和父进程一模一样的子进程
- 除了进程编号不一样
- 子进程无法执行其他逻辑，需要 `exec` 调用

### 进程执行：`exec`

- `fork` 之后，进程需要调用 `exec` 来执行其他功能
- 调用 `exec` 之后
  - 进入内核态
  - 从文件系统读取对应可执行文件，载入内存
  - 解析可执行文件，将需要的部分载入虚拟地址空间
  - 设置参数、内存及寄存器
  - 返回用户态
- 实际上只有两部分在这一阶段被真正载入内存
  - 可执行文件的代码和只读数据
  - 进程运行所需要的栈区域
- 堆和其他区域则会等到真正使用时再进行映射

#### `exec` 与页表

- 以 ChCore 为例，`exec` 主要配置两部分虚拟内存
  - 可执行文件的代码段和数据段
    - 在解析二进制文件时载入
    - 用户代码执行时所需的栈内存
  - 注意
    - 这个实现中并不是只建立VMA再等按需分配
    - 而是在读入时就已经建立了部分页表映射
    - 因为载入二进制文件时，至少需要读入 `header` 部分
      - 读都读了，顺便建一个映射防止 `Page Fault`
      - 但是如果应用程序太大了，`.text` 段放不下，则可以先只设置 VMA

### 进程退出：`exit`

- 进程结束后，调用 `exit` 告知内核
  - 正常退出的进程也会隐式调用 `exit`
  - 进入内核态
  - 内核找到对应的PCB，销毁并回收相关资源（页表、上下文）
  - 返回用户态，切换到其他进程执行（但是该进程的PCB并不回收）
  - 子进程处于僵尸状态，在用户态依然可见，但是并不在运行
- 子进程结束后，由父进程负责回收
  - 因为父进程可能需要子进程的返回状态
  - 在子进程调用 `exit` 到父进程得知返回状态的这段时间中，子进程处于僵尸状态

### 完全回收进程：`wait`

- 父进程可以调用 `wait` 监控子进程的状态
  - 内核需要记录父子进程之间的关系
  - 陷入内核后，操作系统让父进程进入阻塞状态，等待到子进程退出
  - 子进程退出后，内核唤起父进程，执行 `wait` 调用的剩余部分，完成回收工作（回收PCB），子进程正式消亡
- 如果父进程不调用 `wait` （或者子进程还没结束，父进程已经因为不知道什么原因寄了）
  - 常用方案是让 `root` 进行回收
    - `root` 通常不会挂，否则这台机器就寄了
    - 事实上 `root` 的任务就是处理类似的情况

## `fork` 实现的优化

### `fork` 的优势

- 无需任何参数
- 实现简单
- 与 `exec` 解耦，`fork` 负责创建骨架，`exec` 负责进一步填充
- 父子进程的联系为进程的管理提供了便利

### 传统实现的问题

- 过于复杂
  - 随着操作系统不断演进，`fork` 需要不断考虑各种异常情况，防止进程表现出反直觉的逆天行为
- 性能糟糕
  - 需要对远进程执行深拷贝
  - 原进程信息越多，深拷贝的时间开销就越大
- 调用 `exec` 后会使原本拷贝的信息过时失效
- 可能存在一些安全问题

### 写时拷贝

- 只拷贝页表，物理页共享
  - 页表初始为只读
  - 进程需要写内存的时候再分离页表，将两份页表改成读写
- 减少拷贝开销
- 减少调用 `exec` 后导致的无用功
- 写时拷贝仍然会有开销
- 而且拷贝页表的开销仍然存在
  - 拷贝完后，写任何东西都会导致 `Page Fault`
  - 由于 `Page Fault` 需要额外处理，有些情况下反而会拖慢性能
- `fork` 的默认优化策略

### 共享页表

- `vfork`：父进程与子进程共享页表
- 进一步减小拷贝开销
- 如果子进程执行 `exec`，则不会因为页表被重写而无用功
- 但是父子进程的页表完全共享，可能导致冲突
  - POSIX解决思路：阻塞父进程，直到子进程退出或调用 `exec`
  - 通常仅适用于调用 `fork` 后立刻调用 `exec` 的情况，不适用于父子进程并发执行的场景
    - 可作为 `fork + exec` 的优化实现

### 选择性拷贝

- `clone`：允许用户是否控制拷贝内存空间（页表）
- 可以通过 `clone` 的参数指定一些不需要复制的部分
- 也允许通过参数指定子进程栈的位置
  - 避免了父子进程共享地址空间时栈冲突的问题
- 若不拷贝页表，则和 `vfork` 表现类似
  - 但是父子进程拥有独立的栈，不会阻塞父进程
  - 可用于实现多线程
- 若拷贝页表，则与 `fork` 表现类似
- 由于 `clone` 支持细粒度的拷贝控制，具有良好的通用性，已经可以在许多场景中替代 `fork`

### 不拷贝

- POSIX提供了 `spawn`，允许直接创建进程
  - 但是实现上采用了 `clone` + `exec`，仍然会存在少量拷贝

## 上下文切换

### 上下文切换概述

- 现代操作系统通过分时的方法，让进程轮流使用CPU资源
  - 营造出“多个进程同时运行”的假象
- 同时对操作系统提出了要求
  - 需要支持每个进程在**暂停执行**和**恢复执行**之间来回切换

### 上下文切换流程

```text
进入内核态 -> 保存上下文 -> 进程切换 -> 恢复上下文 -> 离开内核
```

### AArch64架构下进程上下文的组成

- **上下文**是使进程在暂停之后能够恢复执行所需要保存的最小状态集合。
- 现代操作系统中，（需要保存的）上下文通常只包含部分寄存器的值
  - 通用寄存器 `x0` 至 `x30`
  - 程序计数器 `PC`
    - 但是实际保存的寄存器是 `ELR_EL1`
  - 特殊寄存器：存储当前CPU的硬件状态和配置
    - `SP_EL0`
    - `SPSR_EL1`

!!! Question 那其他进程状态怎么办？
    操作系统提供了PCB来维护进程相关的数据结构，大部分进程的状态事实上保存在内存中，且可以通过PCB直接获取。

    内存的数据不会因为上下文切换而消失，但是寄存器只有一组。

### 进程的内核态执行

#### 进程的内核数据结构

> 上下文切换的操作需要在内核中执行，此外，中断、系统调用、缺页异常等情况也需要进程进入内核态执行。因此，内核提供了数据结构支持进程在内核态执行

```text
┌─────────────────────┬───
│       vmspace       │
├─────────────────────┤   PCB
│     process_ctx     │
├─────────────────────┼───
│                     │
│                     │
│                     │
├─────────────────────┼───
│       SPSR_EL1      │
├─────────────────────┤
│                     │
│         ...         │
│                     │   Kernel Stack
├─────────────────────┤
│          X1         │
├─────────────────────┤
│          X0         │
└─────────────────────┴───
```

##### PCB

##### 内核栈

- 每个进程拥有自己独立的内核栈
  - 进程在内核中执行代码，仍然有临时数据读写的需求，需要一个栈
- 进程在内核执行时，内核栈的临时数据对用户栈完全不可见
  - 增强了安全性
- AArch64提供了 `SP_EL0` 和 `SP_EL1` 两个栈指针
  - 进入内核执行时，栈指针自动切换为 `SP_EL1`

##### 进程上下文

- 存储位置固定在内核栈的底部

#### 进入内核态

当用户态进程因为异常进入内核态时，需要完成如下几项工作

- 将 `PSTATE` 保存到 `SPSR_EL1`
- 将用户程序进入内核前待执行的下一条指令 `PC` 写入 `ELR_EL1`
- 将栈指针切换到 `SP_EL1`
- 运行状态切换到内核态 `EL1`
- 根据异常向量表的配置，设置 `PC` 执行对应条目所配置的代码
  - 由于此时将根据异常执行对应的逻辑，寄存器的值将被修改，因此进程进入内核后首先需要保存自己的上下文
  - 将寄存器以压栈的形式保存到内存（内核栈）中
    - 这也是为什么上下文保存在内核栈栈底

#### 退出内核态

- 恢复上下文
  - 从内核栈弹出并恢复保存的寄存器
- 将 `SPSR_EL1` 保存的值重设回 `PSTATE`
- 将 `ELR_EL1` 保存的值写会 `PC`
- 将栈指针切换回 `SP_EL0`
- 切换到用户态 `EL0`，继续执行

#### 进程间切换

- 切换时，内核首先根据调度策略选择下一个需要执行的进程
- 然后分两步完成向目标进程的切换
  - 页表切换
  - 内核栈切换

##### 页表切换

- 获取目标进程的页表基地址
  - 通常可以通过PCB获取
- 填入 `TTBR0_EL0`
- 每个进程映射的内核部分完全相同，因此 `TTBR1_EL0` 无需切换

##### 内核栈切换

- 将目标进程的上下文所在地址写入 `SP_EL1`

### 小结（以ChCore为例）

共涉及两次权限等级切换、三次栈切换。内核栈的切换是线程切换执行的分界点。

- 进入内核态时，内核栈初始状态总是为空。相应地，离开内核态时，内核栈将被清空
  - 保证了进程上下文总是在栈底
- 切换上下文时，`SP_EL1` 一定会切换到进程上下文的起始地址

为了满足上述要求，ChCore会对进程上下文切换的触发条件进行限制。

- 例如在内核执行系统调用时不允许上下文切换
  - 因为此时内核栈不为空，上下文切换会丢弃部分栈帧进而产生问题
