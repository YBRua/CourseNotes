# ARM汇编

> “你们的程序都有漏洞，只是不值得被攻击而已。”

## 汇编语言基础

### 编译过程

- 预处理 `*.c -> *.i（文本）`
- 编译 `*.i -> *.s（文本）`
- 汇编 `*.s -> *.o（二进制）`
- 链接 `*.o -> exe（二进制）`
  - “能看这个的……都是特殊的人。”

### 指令

> “很多时候看汇编需要一些想象力。”

- 汇编语言每条指令只完成非常基本的操作

### 操作数

- 寄存器 `<char><number>: X1`
  - ARM64的逻辑上有31个64位通用寄存器。
  - `X0`指向完整的64位
  - `W0`指向末32位
- 中间结果
- 内存引用（虚拟内存） `M[addr]`
  - 虚拟内存 `M` 可以看作一个巨大数组
  - `addr` 的格式由寻址模式决定
    - 偏移量模式 `M[base + offset]`
    - 索引模式
      - 索引模式会**更新** `base` 的值
      - 前索引`[base, offset]!`
      - 后索引`[base], offset`
- 立即数 `#<number>: #4`

### 内存模型

#### 虚拟内存抽象

- 虚拟内存是一个巨大数组
- 虚拟内存中的数据不区分类型
  - 反汇编得到的高级语言和原本的源代码功能一致，但是文本上可能不同

#### 数据块

> `Segmentation Fault`

- 应用程序
- 运行时栈
- 堆
- 共享库
- 内核

## ARM汇编指令简介

### 操作类指令

#### 数据搬移 `mov`

`mov dest, src`

- 源操作数 `src` 可以是
  - 立即数
  - 寄存器
  - 修改过的寄存器
- 目的操作数 `dest` 只能是寄存器
  - 被搬移数据的大小可以由目的操作数长度推测

#### 访存指令

##### `ldr` `str`

`ldr reg, offset` `str reg, offset`

- `reg` 是读内存的数据目标，或写内存的数据来源
  - -内存单元大小可以由寄存器长度推测
- `offset` 可以是偏移量或索引

##### `ldp` `stp`

`ldp reg1, reg2, offset` `stp reg1, reg2, offset`

- 同时将两个寄存器值写入内存，或将内存的值写入两个寄存器
- 先读写 `reg1` 再读写 `reg2`

#### 符号扩展

##### 无符号扩展 `utxb`, `uxth`

##### 有符号扩展 `sxtb`, `sxth`, `sxtw`

#### 算术与逻辑

`NotImplementedError: Buggya too manya`

#### 条件码

- 由 `PSTATE` 寄存器维护
- 描述上一条执行的特殊指令的属性
  - 并非所有ARM64指令都会改变条件码
  - 带有 `s` 后缀的算术或逻辑指令
  - 比较指令与测试指令
- 包括四个标志位
  - `C`：进位标志
  - `V`：溢出标志
  - `N`：上一指令结果为0
  - `Z`：上一指令结果为负

### 控制类指令

#### 跳转指令

- `b <LABEL>`：无条件直接跳转
  - `000101 <IMM26>`
  - 一次跳跃最远范围为 $2^{26}$，跳转距离为 $2^{28}$
- `br <Reg>`：无条件间接跳转
- `b<condition> <LABEL>`：有条件直接跳转

### 过程调用

- 过程/函数调用时另一种形式的无条件跳转：控制流在两段代码之间转移
  - 过程调用后会返回
  - 涉及参数和返回值传递
  - 存在局部变量
  - 涉及寄存器和程序状态保存

#### 调用被调者 `bl`

##### 指令

- 直接调用 `bl <LABEL>`
- 间接调用 `blr <Reg>`

##### 行为描述

- 将返回值存储在**链接寄存器 `LR`**，这里的链接寄存器通常是寄存器`x30`
- 跳转到被调者的入口地址

#### 返回调用者 `ret`

- 根据 `LR` 设置返回地址
- 跳转

#### 内存栈帧结构

##### 程序栈

$$\begin{vmatrix}
  栈顶\\
  运行时栈\\
  \vdots\\
  共享库的内存映射\\
  \vdots\\
  运行时堆\\
  读写段\\
  只读段
\end{vmatrix}$$

- 从高地址向低地址扩张
- 堆叠正在执行的函数的**帧**
  - 每个函数对应一个帧
  - 执行函数时会为被调用者创建一个新的帧
  - 推出一帧只需要调整栈指针 `SP`
  - 不会“清空”原本分配的帧

##### 帧

- 栈帧时再运行时栈上为某个函数分配的内存空间
- 栈指针 `SP` 指示运行时栈的栈顶
- 帧指针 `FP` (寄存器 `x29`) 指示当前帧的顶

##### 栈帧操作

- 创建新栈帧
  - 移动栈指针（分配新的帧）
  - 保存返回地址 `x30`
  - 保存旧帧地址 `x29`

$$\begin{vmatrix}
  上一帧\\
  LR\\
  FP
\end{vmatrix}$$

#### 数据传递

- 使用寄存器 `x0` 至 `x7` 传递**前8个参数**
  - 放不下的参数存入帧
  - 按声明顺序**从右到左**
  - 所有数据对齐到8字节
  - 会导致 `FP` 和 `SP` 指向不一致
    - `SP` 永远指向栈顶
- 被调用者通过 `SP` + 偏移值访问参数
- 使用寄存器 `x0` 传递**返回值**

$$\begin{vmatrix}
  上一帧(FP'指向这里)\\
  \hline
  参数N\\
  \vdots\\
  参数9(SP'指向这里)\\
  \hline
  调用者帧\\
  新的FP和SP指向帧顶
\end{vmatrix}$$

#### 寄存器管理

将寄存器划分为调用者保存和被调者保存

- 调用者保存：调用者调用函数前保存，被调者可以随意使用
  - 寄存器 `x9` 至 `x15`
  - 调用后的值可能发生改变，需要调用者负责保存和恢复
  - 使用较少，一般只存放函数调用前的临时值
- 被调者保存：被调函数在使用前保存，调用者可以随意使用
  - 寄存器 `LR` 和 `FP`、旧 `LR` 和 `FP`、寄存器 `x19` 至 `x28`
  - 保存在栈帧的底部

#### 运行时栈

- 寄存器放不下或者不能放（内存地址）的局部变量将存放于栈上

#### 栈帧架构

$$\begin{vmatrix}
  更靠前的帧\\
  调用者 &
  \begin{vmatrix}
    \vdots\\
    LR''\\
    FP''\\
    参数构造区
  \end{vmatrix}\\
  被调者 &
  \begin{vmatrix}
    被保存的寄存器\\
    局部变量\\
    LR'\\
    FP'(FP)\\
    参数构造区(SP)
  \end{vmatrix}
\end{vmatrix}$$
