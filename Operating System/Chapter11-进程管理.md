# 进程管理

## 进程生命周期管理

> 进程管理，即管理进程的生命周期

- 进程自创建到终止可能经理多个过程
  - 称为进程**状态**
- 不同的系统调用或事件会影响进程的状态

### 进程状态

- 新生
  - 刚被创建
- 就绪
  - 准备执行，但是并未执行
- 运行
  - 正在执行
- 阻塞
  - 等待某个事件
- 僵尸
  - 已退出，资源未完全回收
- 终止
  - 已退出，且资源被完全回收

### 进程控制块 PCB

- 每个进程对应一个元数据，称为进程控制块
  - 是OS记录的进程元数据，对进程本身不可见
  - 存储在内核态
  - “进程的户口本”
  - “我到现在都没看到过我的档案，因为我是用户态的”
- PCB中需要保存的信息
  - 虚拟地址空间
    - VMA
    - 页表
  - 执行上下文
    - `PC` 寄存器
    - `SP` 寄存器
    - 还有些别的

### `fork` 的实现

- Shell调用 `fork`，陷入内核态，触发相关处理函数
- 内核创建新的PCB用以表示新的进程
- 将原有PCB的内容拷贝到新的PCB中（[深拷贝](#深拷贝)）

#### 深拷贝

- 浅拷贝
  - 只复制指针
  - 不复制指针指向的数据结构
- 深拷贝
  - 复制完整的数据结构
  - 不复制指针（因为指针是新开的，指向新的数据结构）

#### 第一个进程

- 第一个进程 `root` 通常由内核创建
  - 同样需要创建PCB
  - 由于没有可拷贝的PCB，所有内容需要手动初始化
- `root` 是所有其他进程的祖先
- `root` 可协助完成进程的回收

#### Fork完成后

- `fork` 只能生成和父进程一模一样的子进程
- 除了进程编号不一样
- 子进程无法执行其他逻辑，需要 `exec` 调用

### 进程执行 `exec`

- `fork` 之后，进程需要调用 `exec` 来执行其他功能
- 调用 `exec` 之后
  - 进入内核态
  - 从文件系统读取对应可执行文件，载入内存
  - 解析可执行文件，将需要的部分载入虚拟地址空间
  - 设置参数、内存及寄存器
  - 返回用户态

#### `exec` 与页表

- 以 ChCore 为例，`exec` 主要配置两部分虚拟内存
  - 可执行文件的代码段和数据段
    - 在解析二进制文件时载入
    - 用户代码执行时所需的栈内存
  - 注意
    - 这个实现中并不是只建立VMA再等按需分配
    - 而是在读入时就已经建立了部分页表映射
    - 因为载入二进制文件时，至少需要读入 `header` 部分
      - 读都读了，顺便建一个映射防止 `Page Fault`
      - 但是如果应用程序太大了，`.text` 段放不下，则可以先只设置 VMA

### `exit`

- 进程结束后，调用 `exit` 告知内核
  - 进入内核态
  - 由内核销毁并回收相关资源（页表、上下文）
  - 返回用户态，切换到其他进程执行（但是该进程的PCB并不回收）
  - 子进程处于僵尸状态，在用户态依然可见，但是并不在运行
- 子进程结束后，由父进程负责回收
  - 因为父进程可能需要子进程的返回状态
  - 在子进程调用 `exit` 到父进程得知返回状态的这段时间中，子进程处于僵尸状态

### `wait`

- 父进程可以调用 `wait` 监控子进程的状态
  - 内核需要记录父子进程之间的关系
  - 陷入内核后，操作系统让父进程等待，直到子进程退出
  - 子进程退出后，内核唤起父进程，完成回收工作（回收PCB），子进程正式消亡
- 如果父进程不调用 `wait` （或者子进程还没结束，父进程已经因为不知道什么原因寄了）
  - 常用方案是让 `root` 进行回收
    - `root` 通常不会挂，否则这台机器就寄了
    - 事实上 `root` 的任务就是处理类似的情况

## `fork` 实现的优化

### 传统实现的问题

- 拷贝开销高
- 调用 `exec` 后会使原本拷贝的信息过时失效

### 写时拷贝

- 只拷贝页表，物理页共享
  - 页表初始为只读
  - 进程需要写内存的时候再分离页表，将两份页表改成读写
- 减少拷贝开销
- 减少调用 `exec` 后导致的无用功
- 写时拷贝仍然会有开销
- 而且拷贝页表的开销仍然存在
  - 拷贝完后，写任何东西都会导致 `Page Fault`
  - 由于 `Page Fault` 需要额外处理，有些情况下反而会拖慢性能

### 共享页表

- `vfork`：父进程与子进程共享页表
- 进一步减小拷贝开销
- 如果子进程执行 `exec`，则不会因为页表被重写而无用功
- 但是父子进程的页表完全共享，可能导致冲突
  - POSIX解决思路：阻塞父进程，直到子进程退出或调用 `exec`

### 选择性拷贝

- `clone`：允许用户是否控制拷贝内存空间（页表）
- 若不拷贝页表，则和 `vfork` 表现类似
  - 但是父子进程拥有独立的栈，不会阻塞父进程
  - 可用于实现多线程
- 若拷贝页表，则与 `fork` 表现类似

### 不拷贝

- POSIX提供了 `spawn`，允许直接创建进程
  - 但是实现上采用了 `clone` + `exec`，仍然会存在少量拷贝
