# 操作系统

> “程序是写死在那边的，也不能和他交流。”
> “操作系统劝你别访问这个。”

操作系统的主要功能

- 保护硬件不被应用程序滥用
- 为应用提供简单、统一的接口来操作硬件

## 三个基本抽象

> “抽象这个东西本身非常抽象”

- 进程 process
- 虚拟内存 virtual memory
- 文件 file

```kkkkk
| <-------------Process--------------> |
            | <----Virtual Memory----> |
                          | <--File--> |
| Processor | Main Memory | IO Devices |
```

### 进程

程序运行时，操作系统会提供一种假象

- 操作系统中**只有**这个程序在运行
- 一个程序看起来独占了所有处理器、主存、IO设备
  - 无间断地依次执行指令
  - 独占了所有内存
  - 独占了所有IO

进程
: 一个正在运行的程序

- 一个程序可以对应多个进程
  - 一个程序开好几个
  - 一个程序使用多进程
- 多个程序也可以对应一个进程
  - 比如GPU Code fusion

进程由两个部分组成

- 用户部分
- 操作系统部分
  - （狭义上）又称为内核 kernel
  - 由所有进程共享

#### 用户态与内核态

- 内核态
  - 可以执行任何指令
  - 可以访问任何内存地址
- 用户态
  - 不能执行特权指令
  - 不能直接访问地址空间中的内核部分
  - 只能通过**系统调用**达成上述目的
    - 系统调用是应用程序实现这些目的的唯一合法方式
    - “你除个零能进kernel，触发Segmentation Fault也能进kernel”
- 在处理器中通常使用专门的**状态位**进行区分

### 虚拟内存

- 每个进程都独占了虚拟内存
- 虚拟地址空间
  - 程序的代码与数据、堆、共享库、运行时栈
  - 内核
- 通过特殊的硬件来快速翻译虚拟地址

#### 私有地址空间

每个进程都拥有各自的私有地址空间

### 文件

- 每个IO设备都被抽象为一个文件
- Unix IO
  - 提供有限的系统调用来读写“文件”
  - 所有输入输出都通过这些系统调用完成
- 每个文件都有一个独立的编号 File Descriptor, FD

## 异常 Exception

### 用户态与内核态的控制流转换

- 跳转指令 `b` 和过程调用/返回指令 `bl` `ret` 都只能在同一种模式内跳转
- 需要新的指令 `svc` `eret`

### 系统调用

- 系统调用参数不超过8个，放置于寄存器 `x0` 至 `x7`
- 寄存器 `x8` 用于存放系统调用编号
  - `svc` 指令将直接根据 `x8` 跳转至系统调用
- 返回值存放于 `x0`

### 事件 Event 与异常 Exception

```mermaid
sequenceDiagram
    用户态 ->> 内核态: 异常
    activate 内核态
    Note right of 内核态: 异常处理函数
    内核态 -->> 用户态: 返回指令（可选）
    deactivate 内核态
```

- 事件与当前指令可能有关，也可能无关
  - 事件可以理解为触发异常的行为
  - `svc` `eret`（有关）
  - 缺页、溢出（有关）
  - 定时器结束、IO请求完成（无关）
- 异常处理结束后，将通过以下某种方式之一返回控制权
  - 回到异常发生时正在执行的指令
  - 回到异常发生时的下一条指令
  - 结束当前进程

### 异常向量表

- 操作系统内核预先在一张表中准备好不同类型异常的处理函数
  - 基地址存储在 `VBAR_EL1` 寄存器中
- 发生异常时自动跳转到对应位置
- 一共16项，其中4条最为常用
  - 各个处理函数根据各自处理的异常类型进一步调用其他函数
- 处理器将异常类型存储在指定寄存器 `ESR_EL1` 中

### 异常类型

#### 同步异常

- 由于执行指令而发生时间引起的异常
  - 同步：与当前进程有关
- 陷阱 Trap
  - 有意触发的异常
  - 例如断点、系统调用
  - 异常处理函数返回到下一条指令
- 故障 Fault
  - 非有意触发，但是可能可以恢复（但是不一定能成功恢复）
  - 例如缺页异常、保护错误
  - 控制权将返回到当前指令，或终止当前进程
- 终止 Abort
  - 非有意触发、不可恢复
  - 当前进程将被终止

#### 异步异常：中断 Interrupt

- 由处理器外部的事件导致
  - 外部设备设置处理器的中断引脚
  - 处理函数返回到被中断的下一条指令
- 例子
  - IO中断
    - `CTRL + C` Keyboard interrupt
    - 网络收到数据包
    - 磁盘从某个扇区读取完成
  - 硬复位
    - 重启按钮
  - 软复位
    - `CTRL + ALT + DEL`
- 流程
  - IO设备通过设置处理器引脚来发起终端
  - IO设备向总监发送一个信号，表示发起中断的是哪个设备
  - 处理器将打断当前执行流，跳转到中断处理函数

### 信号

- 操作系统向应用程序发送的信息
  - 例如 `Segmentation Fault` 发生时，向应用程序发送 `SIGSEG` 信号

### 内存映射IO

- IO设备抽象为内存地址，对IO设备的操作抽象为读写内存的操作
- 每个设备可以被映射到多个IO端口
