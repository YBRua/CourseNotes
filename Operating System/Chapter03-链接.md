# 链接

## 什么是链接

### 单个源文件

- 效率低下：每次修改都需要重新编译整个源代码
- 模块化差：难以实现代码复用

> “你的老板可能不知道怎么实现这个事情，但是他会提这个需求。”
> “一个上进的程序员也会提这样的需求。”

```mermaid
flowchart LR
  main.c-->|编译器|program
```

### 文件拆分

- 将整个 `main.c` 拆分成多个源文件
  - 每个文件分别编译
- 单独编译后，只有跨文件的函数调用（跳转）尚未确定

```mermaid
flowchart LR
  main.c-->|编译器|MO
  util.c-->|编译器|UO
  MO[main.o]-->|链接器|program
  UO[util.o]-->|链接器|program
```

### 链接器

#### 链接器做什么

#### 何时执行

- 编译时：将源代码翻译为机器码时
- 加载时：加载到内存并执行时 `dll`
- 运行时：执行过程中

#### 编译器驱动程序 (driver)

- 负责总体协调翻译和连接过程中的所有阶段
- 通常包含在编译系统中 (e.g. `gcc`)
  - `cpp` 预处理
  - `cc1` 编译
  - `as` 汇编
  - `ld` 链接

#### 可重定向目标文件 (Relocatable Object File)

- 包含二进制代码和数据
- 可以与其他可重定向目标文件链接成为可执行文件

#### 节

- 可重定向目标文件中的代码和数据被划分为不同节
- `.text` 指令代码
- `.data` 初始化的全局变量和静态变量
- `.bss` 未初始化的全局变量和静态变量

#### 符号解析

- 解析对当前文件之外的引用
- 外部引用
  - 引用定义在其他文件中的符号
  - 在可重定位目标文件中填充为 `0`
  - 在链接时需要解析

#### 重定位

- 将可重定向文件的相对地址解析为绝对位置，将引用更新到真实的绝对位置

## ELF文件格式（可执行可链接格式）

- `Linux` 下统一的目标文件格式
  - 可执行目标文件（对应于 `Windows` 下的 `.exe` 格式）
  - 可重定向目标文件 `.o`
  - 共享目标文件 `.so`
    - 可以加载到内存中
    - 无需在编译时链接，支持动态连接

### ELF文件的Metadata

| Metadata |
| :------: |
|          |

#### ELF Header

- ELF文件的第一部分
- 通常用于存放元数据
  - Magic Number
  - 类型（`.o`，`.so`，可执行）
  - 机器架构
  - 字节顺序（大小端）
  - 头部表的位置（文件内偏置）

#### 节头部表 Section Header Table

- 节
  - 除头部和头部表外划分为若干区域
  - 每个节在文件中是一块连续的字节（可能为空）
  - 互不重叠
- 每个节都有一个节头部描述，记录在节头部表中

#### 字符串表 `.strtab`

- 集中ELF文件中所有C风格字符串（以`\0`结尾的字符数组）
  - 字符串原有的位置替换为内存地址
  - 使文件更规整

#### 调试信息 `.debug` `.line`

- 便于调试的节，可选
- `.debug`
  - 调试符号表，包括变量、`typedef`、C源文件
  - 使用 `gcc -g` 生成
- `.line`
  - C源文件的行数与 `.text` 节中指令的映射
  - 一段高级代码被翻译成了哪几段汇编代码

#### 只读段 `.text` `.rodata` 和读写段 `.data` `.bss`

- `.text` 代码
- `.rodata` 只读数据
- `.data` 初始化的全局和静态变量
- `.bss` 未初始化的全局和静态变量
  - Q: Why `bss`? A: `block started by symbol` / `better save space`
  - 不占文件空间，但是在节头部表中有记录
  - 运行时分配内存，默认初始值为 `0`
  - 初始化为 `0` 的全局变量也可能被编译器优化到 `.bss` 中

#### 符号表 `.symtab`

- 每个可重定位目标文件有一个符号表，记录符号的定义和引用信息
- 编译器将符号输出到汇编文件
- 汇编器将符号构建成符号表

##### 符号

- 定义(defined)的全局符号
- 引用(referenced)的全局符号
- 局部（静态）符号
  - 局部非静态变量不作为ELF符号表的符号，而是直接放置在运行时栈或寄存器上

#### 重定位 `.rel.text` `.rel.data`

- 对于每个未知的引用，在链接时需要重新定位

##### 重定位

- 合并各个模块，给每个符号分配运行时的地址
- 符号解析
- 地址填充

## 可执行目标文件

|          Metadata           |
| :-------------------------: |
|       ELF Header 只读       |
|        `.init` 只读         |
|        `.text` 只读         |
|       `.rodata` 只读        |
|        `.data` 读写         |
|         `.bss` 读写         |
|      `.symtab` 不加载       |
|       `.debug` 不加载       |
|       `.line` 不加载        |
|      `.strtab` 不加载       |
| Segment Header Table 不加载 |

### ELF Header

- 整体信息
- 程序入口 `e_entry`：会被加载到 `PC`中
- 程序头部表信息

### 程序头部表 Program Header Table

- Program (Segment) Header Table
  - `p_type`
  - `p_flags` 运行时权限 `rwx`
  - `p_offset` 段在文件中的起始偏移
  - `p_filesz` 段在文件中的大小
  - `p_vaddr` 内存中的起始虚拟内存地址
  - `p_memsz` 段在内存中的大小
    - 由于有 `.bss`，内存大小和文件大小可能不一样
  - `p_align` 段起始地址的对其要求
    - 通常为 `4K` 或 `2M`

### 加载到内存后

#### 启动代码 `_start`

- 所有C程序都相同的程序入口
- 定义在 `crt1.o` 中
- `__libc_start_main`
  - 初始化执行环境
  - 调用 `main`
  - 处理返回值
  - 返回控制权

#### 加载器

- 通过 `execve` 调用操作系统提供的功能
- 将代码和数据加载到内存中
- 跳转到程序入口

## 静态链接与库

### 静态库 `.a`

- 将一组可重定位目标文件拼接成一个单独的文件
- 链接器在打包的 `.o` 文件中找未解析的外部符号
- 然后链接对应的 `.o` 文件
