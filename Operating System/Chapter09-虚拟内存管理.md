# 虚拟内存管理

## 虚拟内存段和 VMA

### 段

- OS采用**段**管理虚拟地址
  - 段内连续，段间非连续
  - 合法虚拟地址段：代码、数据、堆、栈
  - 非法虚拟地址段：未映射的代码段
    - 一旦访问则触发 `Segmentation Fault`
- 记录应用程序中已分配的虚拟地址区域
  - 代码段：读、执行
  - 数据段：读
  - 堆：读、写
  - 栈：读、写

### VMA

#### 添加 VMA

- 途径1：OS在创建应用程序时分配
  - 数据
  - 代码
  - 栈（初始为空）  
- 途径2：应用程序主动向OS发出请求
  - `brk()`：扩大、缩小堆区域
    - OS也可以在应用程序创建时分配初始的堆的VMA
  - `mmap()`：申请空的虚拟内存区域，或申请文件内存映射的虚拟内存区域
- 用户态的 `malloc()` 也会改变VMA
  - 通常是调用 `brk`
  - 但是部分实现也会调用 `mmap`

#### `mmap`

- 通常用于把一个文件（或文件的一部分）映射到内存

```c
void *mmap(
    void *addr, //手动指定虚拟内存起始地址
    size_t length, // 手动指定虚拟内存区域长度
    int prot,
    int flags,
    int fd,
    off_t offset)
```

- 也可以不映射任何文件，仅仅新建虚拟内存区域
  - `fd=-1`
- OS 不允许两块 `mmap` 的内存区域重叠
- 执行 `mmap` 后，VMA 中新增一个 `mmap` 开出来的段

#### VMA 与页表

- OS通过VMA记录应用程序能够访问的虚拟地址
  - 未映射的区域没有对应的VMA结构
- OS通过页表控制应用程序能访问的虚拟地址
  - 未分配的虚拟地址没有页表

#### 操作系统填写页表

- 立即映射
  - 每个虚拟页都对应一个物理页
- 延迟映射
  - 有些虚拟页不对应任何物理页
  - 对应的数据在磁盘上
  - 没有对应的数据（初始化为0）

!!!question VMA是否冗余
    如果只有立即映射一种模式，那么页表和VMA的功能有重叠，VMA会显得多余。但是在增加了延迟映射的情况下，有些已分配的虚拟地址也没有页表项，因此需要VMA。

## 延迟映射-按需调页 Demand Paging

### 物理内存作为虚拟地址空间的Cache

#### 为什么

- 有时应用程序所需的物理内存总和超出了机器上实际搭载的物理内存总量
- 有时应用程序预先申请了很大的内存，但是很多虚拟页最终都没有用到

### 流程

1. 操作系统为应用程序创建VMA，但是并不把整个应用程序加载到内存
2. CPU访存时发现没有页表
3. CPU抛出 `Page Fault`
4. OS处理 `Page Fault`
   1. 检查VMA
   2. 根据VMA分配并初始化内存
   3. 更新页表
5. 回到用户态，重新运行访存指令

!!!note
    只在触发了 `Page Fault` 时才分配物理内存，节省了物理内存使用。

### 换页机制

#### 基本思想

- 用磁盘作为物理内存的补充，且对上层应用透明
- 应用对虚拟内存的使用不受物理内存大小限制
- “骗应用程序说我有很大很大很大的物理内存”

#### 基本实现

- 磁盘上划分专门的Swap分区或Swap文件
- 在处理缺页异常时，触发物理内存页的换入换出

#### 页命中

- CPU将虚拟地址发送给MMU
- MMU查TLB，如果未命中则从页表中取出页表项
- MMU将物理地址发送给Cache或内存
- Cache或内存将内容返回给CPU

#### Page Fault

- CPU将虚拟地址发送个MMU
- MMU查TLB，如果未命中则从页表中取出页表项
- 页表项有效位为`0`，触发`Page Fault`
- Handler找到一个victim page
  - 如果该页被修改过，则需要写回磁盘
- Handler将新的页载入内存，并修改页表
- Handler返回触发`Page Fault`的指令，重新运行