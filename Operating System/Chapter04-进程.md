# 进程

## 概述

### 进程如何产生

- 在 `shell` 中输入可执行文件的名称，或在图形化界面双击应用程序
- 应用程序也可以自行创建新进程
  - 在新进程中可以运行其他应用程序或者运行和自己一样的程序

### 控制流

- 物理控制流
  - 逐条读取并执行程序指令
- 并发 Concurrency：多个进程同时运行
  - 如何支持并发
    - 多任务交错 Interleaving
    - 虚拟地址
  - 如何实现交错执行
    - 上下文切换 Context Switch

## 上下文

- 内核为每个进程维护一个**上下文**
- 包含了被中断进程恢复执行所需要的所有状态
  - 程序代码和数据
    - 存储在内存
  - `PC`、寄存器、状态寄存器
  - 用户栈、内核栈
    - 属于上下文范畴
    - 不需要额外保存操作（虚拟内存抽象保证了栈不需要额外保存和恢复）
  - 环境变量
  - 内核数据结构
    - 进程表、页表、文件表
    - 只需要记住在哪能找到，不需要整个保存
- 看着很多，但是实际要保存的主要是一些寄存器，因此不会花很久

### 上下文切换 Context Switch

#### 时间片调度 Time Slicing

- 将时间段划分为多个时间片
- 每个进程只能在分配给自己的时间片中运行
  - 时间到了会被操作系统赶走
- 异常控制流的高层表现形式

#### 上下文切换的时机

通常会在两种情况下执行上下文切换

- 用户执行系统调用并进入内核
  - 会导致进程阻塞的系统调用，例如 `read` / `sleep`
  - 即使系统调用没有执行，内核也可以决定进行上下文切换
- 中断导致的上下文切换
  - 时钟中断：时间片到了

#### 时间片切换频率

- 频繁地时间片切换可以提高用户体验，但是会导致切换带来的总时间增加
  - 因为看上去每个进程都可以立刻得到响应
- 例如
  - 一台服务器可能需要较低频率地切换
  - 而一台PC可能需要较快频率地切换

### 调度器 Scheduler

- Policy
  - 决定是否要在进程执行过程中，抢占当前的进程
    - 例如是否有系统调用、时间片是否到了
  - 选择恢复一个先前被抢占地进程
- Mechanism
  - 抢占 Preempt 当前执行的进程
    - 需要保存当前进程的上下文
  - 恢复 Restart 被调度到的进程
    - 恢复该进程的上下文
    - 把控制权交给该进程

## 并发 Concurrent

### 逻辑控制流

- 每个进程都有自己的逻辑控制流
  - 不会影响其他进程的状态

### 并发

- 两个进程同时运行，则称为并发
- 否则为顺序执行（串行）
- 并发进程的控制流实际上是**交错执行**的
- 但是可以并发进程视为相互间**并行执行**

### 进程的三种状态

> 你不要调度到一个进程上来，它说它不想执行，然后它又走了

#### 状态

- 运行态
  - 正在CPU中执行，或者正在等待被执行
  - 最终一定会被调度
- 暂停态/阻塞态
  - 进程执行被挂起，未来不会被调度
  - 比如在等IO、等网络
- 终止态
  - 进程永远终止运行
  - “也许你这个应用的尸体中有一些信息，其他人需要”

#### 状态切换

状态切换通过信号实现

- 运行态的进程可以暂停
  - 收到信号，例如 `SIGSTOP`
- 阻塞态的进程可以运行
  - 收到信号，例如 `SIGCONT`
- 进程终止方式
  - 收到信号的默认处理方式时终止进程
  - 例如从 `main()` 返回，调用 `exit()`

## 创建和终止进程

### 进程ID

- 进程 ID
  - 每个进程都有一个唯一的、正数的PID
- `Getpid()`
  - 返回调用进程的PID
- `Getppid()`
  - 返回调用进程的**父进程**的PID
  - 父进程是创建了调用进程的进程
  - 返回 `pid_t` 类型的值，在 `linux` 中为 `int`
- `Kill(pid)`
  - 经操作系统，向对应ID的进程发送 `SIGKILL` 信号

### Exit函数

- `void exit(int status)`
- 没有返回值
- 终止进程时可以附带一个 `status` 表示被终止进程的终止状态~~遗言~~
  - 父进程可以获取这个状态（如果父进程需要的话）

### Fork函数

- `pid_t fork(void)`
  - 无参数
  - 返回值：子进程为 `0`，父进程为子进程 PID，出错为 `-1`
- 创建的新进程和父进程**几乎相同**
  - 相同
    - 子进程获得一份**相同但独立**的父进程用户态虚拟地址空间的复制
    - 获得了父进程所有打开的文件标识符的复制
  - 不同
    - pid
    - 返回值

#### Fork的调用与返回

- 调用一次
  - 在父进程中调用一次
- 返回两次
  - 在父进程中，返回子进程的PID
  - 在子进程中，返回 `0`

#### 父进程与子进程的并发执行

- 父进程和子进程同时运行
- 在内核调度下，由内核以任意可能的顺序交错执行
- 因此并不能确定父进程和子进程谁先结束

#### 重复但独立的地址空间

```c
int main()
{
    pid_t pid;
    int x = 1;
    pid = Fork();
    if (pid == 0)
    {
        // child process
        printf("child: x=%d\n", ++x);
        exit(0);
    }
    // parent
    printf("parent: x=%d\n", --x);
    exit(0);
}
```

- 上述代码会打印两次，一次是 `x=0`，一次是 `x=2`
- 打印顺序不能确定，取决于内核调度器
- 父进程和子进程里的 `x` 不是同一个 `x`

## 回收进程

### 僵尸进程

- 进程以终止态存在，但是并未被从系统中移除，等待父进程回收
- 如果父进程在自己终止前没有回收僵尸子进程，内核会安排 `init` 进程回收这些子进程
- 对于长时间运行的程序，应该总是及时回收僵尸子进程
  - 防止僵尸进程占用过多系统资源

#### `init` 进程

- `PID` 为 `1`
- 在系统初始化时由内核创建

### `waitpid`

- `pid_t waitpid(pit_t pid, int* status, int options);`
  - 成功时返回子进程 PID
  - 出错时返回 `-1`
    - 没有子进程 `ECHILD`
    - 被打断 `EINTR`
  - 此时子进程已经被回收
- `pid_t pid`
  - `>0`：等待某个特定的子进程
  - `-1`：等待所有子进程
