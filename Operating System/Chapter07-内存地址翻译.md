# 内存地址翻译

## 物理地址

### 问题

> “编译器会非常郁闷”

- 运行时物理内存地址被占用
- 物理内存不够

### 解决方案

- 假设应用运行时会独占所有内存，且内存足够大
  - 虚拟内存空间：$2^{32}$ Byte 或 $2^{64}$ Byte
- CPU将物理地址翻译到虚拟地址，由操作系统来配置如何翻译

## 虚拟地址

### CPU访问虚拟地址

- 通过 Memory Management Unit (MMU) 按照一定的规则进行翻译

### 分段机制

#### 直觉

- 虚拟地址分为 `段号` 与 `段内地址`
  - `段号` 由操作系统决定
    - 根据 `段号` 给 `段内地址` 增加偏移量
  - `段内地址` 由编译器生成
  - 由操作系统配置 `段表`，CPU查表翻译内存地址
  - `段表` 存在内存里，CPU只记录 `段表` 的初始地址和偏移量
- 每个段的长度是可变的

#### 细粒度分段

- 按代码、数据、堆、栈等，将一个程序分成多个段

#### 问题

- 对物理内存连续性的要求
  - 物理内存必须以段为单位进行分配
- 内存利用率
  - 外部碎片：段与段之间留下的碎片空间
  - 内部碎片：段内预留的未使用的碎片空间

### 分页机制

- 分页
  - 虚拟地址空间划分为**连续、等长**的虚拟页
  - 物理内存也划分为连续、等长的虚拟页
  - 虚拟内存和物理内存的页长度相等
- 虚拟地址记录为 `虚拟页号` + `页内偏移`
  - 翻译时只把 `虚拟页号` 翻译到 `物理页号`
  - `页内偏移` 不会因翻译而改变
- 使用页表进行内存映射

### 优势

- 物理内存离散分配
  - 任意虚拟页可以映射到任意物理页
  - 降低内存连续性要求
- 主存资源利用率更高

## 内存翻译

- 参数
  - $N = 2^n$ 为虚拟地址限制
  - $M = 2^m$ 为物理地址限制
  - $P = 2^p$ 为页的大小
  - $V = \{0,1,\dots,N-1\}$ 为虚拟地址空间
  - $P = \{0,1,\dots,M-1\}$ 为物理地址空间
- $Map(a): V \mapsto P \cup \{\emptyset\}$
  - 若虚拟地址 $a$ 的数据不在物理地址空间，或在磁盘上，则返回值为 $\emptyset$，触发缺页异常
  - 若虚拟地址 $a$ 的数据存在物理地址 $a'$，则返回 $a'$

## ARM64架构的内存翻译

### 多级页表

#### 单级页表的问题

- 假设64位虚拟地址空间，页大小为4KB，页表项为8字节（64位内存地址）
- 则需要 $2^{64} / 4K * 8 = ExtremelyManyGB \approx 33PB$
- 噔噔咚
- 事实上即使是32位虚拟地址空间，也需要 $4MB$
  - 在进程较多的情况下这也是不可接受的
- 单级页表是稀疏的

#### 多级页表

- 如果某一级页表的条目为空，则下一级页表也不存在，则无需给次级页表分配内存空间

#### AARCH64的多级页表

- AARCH64体系结构下最常见的是4级页表
- 前16个bit `63:48` 必须全是 `0` 或 `1`
  - 虚拟空间最大为 $2^{48}$，即 256TB
- `47:39` 0级页表索引
- `38:30` 1级页表索引
- `29:21` 2级页表索引
- `20:12` 3级页表索引
- `12:0` 页内偏移（页大小为4KB）

### 页表基地址寄存器

- AARCH64 体系结构下有两个基地址寄存器
  - `TTBR0_EL1`
  - `TTBR1_EL1`
  - 根据虚拟地址第 `63` 位选择

### 页表使能

- 机器上电时会进入物理寻址模式
  - 需要配置寄存器使能页表，然后进入虚拟寻址模式
- AARCH64 体系结构下需要将 `SCTLR_EL1` 第 `0` 位置为1

### 页表页

- 每级页表有若干离散的页表页
  - 每一个页表页占用一个物理页
- 第0级页表有且只有一个页表页
- 每个页表页中有512条
  - 每页4KB，每个条目8Byte，因此共512条

#### Level3 页表项

- 一个页表索引占不满64位，为了对齐时利用空间，空余的位（末12位和首16位）被用于存储权限等信息
- `0` 位表示该项是否有效
- `1` 位必须是1
- `54` 位 `XN` 为1则表示 EL0 不能执行
- `53` 位 `PXN` 为1则表示 EL1 不能执行
- `51` 位 `DBM` 为1则表示该页被修改了

## Translation Lookaside Buffer TLB

- 多级页表压缩了页表大小，但是增加了内存访问次数
- TLB可以看作页表的缓存
  - 线性查找表，但是在硬件实现中可以并行化
  - 缓存有限数目的页表项
- 如果 TLB 命中，则直接从TLB获取物理地址
- 寄了就寄了，还是得查页表
