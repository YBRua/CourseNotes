# 文件

## Unix IO

### Unix 文件

- Unix 文件是一串字节序列
- IO设备也被抽象为文件
  - `Unix` 提供基于文件的底层应用接口，即 Unix IO
  - 所有输入、输出都通过读写文件完成

### 文件类型

- 普通文件 regular file
  - 文本文件
    - `Linux` 中包含一系列文本行，每一行都是字符串，末尾换行符由 `\n` 表示
  - 二进制文件
  - 目录 directory
    - 由一组链接组成
    - 每个链接将一个文件名映射到一个文件或目录
    - 每个目录至少有两个链接
      - `.` 当前目录
      - `..` 父目录
  - 套接字 Socket
    - 用于跨网络进程交互
  - 其他文件
    - 命名管道 named pipes
    - 符号链接 symbolic links

### 目录层级

- `Linux` 内核采用单个层次化目录来组织文件
  - `/` 代表根目录
  - 每个文件都是目录的直接或间接后代

### 打开文件

- 内核打开相关文件，返回一个非负整数，作为**文件标识符** file descriptor `fd`
  - `fd` 代表该文件，用于后续对文件的操作
  - 对每个打开的文件，保证获得该池中最小的文件标识符
  - 特殊标识符
    - `STDIN_FILENO: 1`
    - `STDOUT_FILENO: 2`
    - `STDERR_FILENO: 3`
- 内核跟踪记录每个进程的所有打开文件的信息
  - 对每个打开的文件，记录文件内偏移 `k`
- 应用只需要记录内核返回的文件标识符

### 关闭文件

- 释放在文件打开时创建的数据结构
- 把文件标识符返回到可用标识符池

### 读文件

- 从文件中复制 $m$ 字节到内存
  - 若文件剩余长度小于 $m$，则触发 `end-of-file`
    - `EOF` 可以被应用程序检测，但是文件尾实际上并不存在 `EOF`
- `ssize_t read(int fd, void* buf, size_t count)`
- `ssize_t write(int fd, void* buf, size_t count)`
  - 成功：返回读入的字节数
  - 遇到文件尾：`0`
  - 失败：`-1`

## 加载和运行进程

### 加载和运行 `execve`

- `int execve(const char* filename, const char* argv[], const char* envp[]);`
- 只调用一次，不会返回
  - 仅在运行报错的时候返回调用程序

## 内存映射

- 将文件映射到内存
  - 通过读写内存来读写文件（无需使用 `read` `write`）
- `void *mmap(...)`

### 共享映射与私有映射

- 共享映射
  - 会立刻写入磁盘
  - 对其他共享映射了文件的其他进程可见
- 私有映射
  - 不会立刻写入磁盘
  - 对其他进程不可见
  - 对 `Fork()` 后的子进程（私有映射）
    - 子进程将继承父进程的所有内存映射
    - 子进程可以观察到父进程在 `Fork()` 前的所有修改
    - `Fork()` 后的修改只对自身进程内可见
    - 可以实现父子进程的交流（但是不能两个人一起写否则就无了）

## SHELL

### Unix Shell

- 一个交互型应用程序，用于代表用户运行其他程序
- 依次迭代执行**读取输入** `read` 和**解析命令** `eval`，直到进程终止

### 解析命令

- 使用空格分割命令行参数
- 建立 `argv` 数组
  - 要求每个元素指向一个参数
  - 传递给 `execve` 函数
  - 技巧：把命令行输入中的空格 `\s` 先替换成 `\0`
- 加在命令行最后的 `&` 用于表示是否在后台执行，`&` 不计入 `argv`
