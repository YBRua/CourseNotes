# 多线程

## 线程概念的引入

- 早期进程数量通常超过CPU核数
  - 通过简单的分配和进程调度，即可让每个核得到一个进程
  - 一个进程同时只能被调度到其中一个核心上运行
- 虽然可以用 `fork` 创建多个进程来实现多核运行，但是 `fork` 产生的两个进程隔离过强，共享数据协调困难

### 轻量级进程

> 能否让单一进程跨和执行？

- 共享页表的进程
- 两个共享页表的线程的 TCB 中，页表地址相同

### 线程

**线程**：进程内部可以有多个独立的执行流，它们共享一份进程的地址空间，但是各自拥有独立的运行时状态（上下文和栈）。

#### 包含的内容

- 独立的上下文
  - 实现跨核支持
- 独立的用户栈
  - 常规栈操作不互相影响
    - 函数调用返回等
- 共享代码和数据部分
- 共享的堆
  - 可以共享动态分配的内存
  - 堆管理起来比较复杂，而且共享堆不会太多影响；而入栈出栈是底层汇编触发的，不好同步，独立的栈可以简化设计

```text
┌────────────────────────────┐
│    Kernel Code and Data    │
├────────────────────────────┤
├────────────────────────────┤
│        Kernel Stack        │
├────────────────────────────┤
│                            │
├────────────────────────────┤
│       Thread Stack 1       │
├────────────────────────────┤
├────────────────────────────┤
│       Thread Stack 2       │
├────────────────────────────┤
├────────────────────────────┤
│       Thread Stack 3       │
├────────────────────────────┤
│                            │
├────────────────────────────┤
│         Shared Lib         │
├────────────────────────────┤
│                            │
│                            │
├────────────────────────────┤
│            Heap            │
├────────────────────────────┤
│            Code            │
├────────────────────────────┤
│            Data            │
└────────────────────────────┘
```

#### 进程与线程

- 相似
  - 都可以与其他进程/线程并发执行（可能在不同核心上）
  - 都可以进行上下文切换
    - 在引入线程之后，调度单位由进程变为线程
    - 线程拥有独立的上下文
- 不同
  - 线程比进程开销更低
  - 同一进程的不同线程共享代码和数据

## 操作系统提供的线程相关接口

- 常用库 POSIX Threads `pthreads`
  - 包含创建、回收、退出线程的各种接口
- 一个线程执行系统调用可能会影响该进程的所有线程
  - 一个线程直接调用 `exit` 会导致所有线程都退出
- 可以使用 `thread_join` 等待特点线程退出并回收
- 可以使用 `thread_detach` 让线程退出时自动回收相关资源
- 可以使用 `thread_exit` 只退出当前线程，防止主线程结束后调用 `exit` 造成其他线程被一并终止

## 线程管理与实现

### 多线程进程的 `fork`

#### 会发生什么

- 假设 `thread_1` 调用 `fork`
  - 会创建一个新的进程
  - 新进程的内存空间里会有原进程的所有线程的栈
  - 但是只有 `thread_1` 的 `SP` 指向了自己的栈
  - 其他线程的栈没有人用
  - `fork` 之后的进程只有1个线程在工作
- 这种实现相对比较简单，但是显然会造成内存资源的浪费
- 然而如果 `fork` 时拷贝了进程的所有线程，则可能出现迷惑行为
  - 比如一个线程 `fork` 时，另一个线程恰好在写文件
  - 那么 `fork` 后如果新产生一个正在写文件的线程，该文件就会被写两次
- 因此事实上建议程序员不要 `fork` 一个正在多线程执行的进程

### 线程控制块 TCB

- 原有的PCB中维护一个链表，记录该进程的所有线程
- 由于线程拥有独立的上下文，因此进程控制块不再需要维护指向上下文的引用，但是相应地，进程现在需要维护进程包含的所有线程
  - 这可以通过链表 `thread_list` 实现

```cpp
struct process {
  struct vmspace *vmspace;
  struct list_head thread_list;
}
```

- 线程控制块 Thread Control Block 包含以下内容
  - 线程上下文。与之前的进程上下文对应。保存了线程在暂停后能恢复执行所需要保存的最小状态集合
  - 所属进程信息。进程与线程互相引用，便于管理
  - 进程间通信相关。

```cpp
struct thread {
  struct thread_ctx thread_ctx;
  struct process *process;
  struct ipc_connection *active_conn; // beyond the scope
  struct server_ipc_config *server_ipc_config; // beyond the scope
}
```

- 除此之外，操作系统还会为每个线程配备独立的内核栈，以保证各个线程进入内核后互不干扰
