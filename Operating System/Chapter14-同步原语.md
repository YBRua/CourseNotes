# 同步原语

> “一个人要怀胎十月才能生一个宝宝”
> “那十个人呢”

## 竞争条件 Race Condition

- 竞争条件
  - 当两个或以上的线程（也可能是进程）同时对共享的数据进行操作，且其中至少有一个写操作
  - 对该共享数据的操作结果依赖于这些线程（或进程）的执行顺序

## 同步原语

### 同步原语 Synchronization Primitives

同步原语是一个由平台（如操作系统）提供的用于帮助开发者实现线程之间同步的软件工具

### 生产者消费者问题

#### 模型

- 有一个有限长度的 `buffer`

```c
while (prodCnt - consCnt)
```

#### 单生产者、单消费者

#### 多生产者

### 临界区抽象 Critical Section

```mermaid
graph LR
    申请进入临界区-->临界区部分
    临界区部分-->通知退出临界区
    通知退出临界区-->其他部分
```

#### 三个要求

- 互斥访问
  - 在同一时刻，有且只有一个线程可以进入临界区
- 优先等待
  - 当一个线程申请进入临界区后，必须在有限时间内
- 空闲让进

### 互斥锁 Mutual Exclusive Lock Mutex

- 可以保证同一时刻只有一个线程能够拿到锁

#### 接口

- `lock`
  - 若当前没有其他线程拿到:lock:，则拿到:lock:并进入临界区执行
  - 否则不断等待其他线程释放:lock: (busy loop)
- `unlock`
  - 释放:lock:

### 条件变量

> 线程等待锁时使用busy loop，如何避免无意义的等待？
> > “这显然不符合我们碳中和、碳达峰的要求”

条件变量利用睡眠/唤醒机制，避免无意义的等待

#### 接口

- 等待
  - `void cond_wait(struct cond *cond, struct lock *mutex)`
  - 放入条件变量的等待队列
  - 阻塞自己，释放:lock:，调度器可以调度到其他线程
  - 被唤醒后，重新获取:lock:
- 唤醒
  - `void cond_signal(struct cond *cond)`
  - 检查等待队列是否为空
  - 如果有等待中的线程，则将其移出队列并唤醒

### 信号量 Semaphore

- 另一种同步原语，便于在多个线程之间管理资源
  - 信号量用于协调（阻塞/放行）多个线程共享有限数量的资源
  - 语义上，信号量的值记录了**当前可用资源的数量**
    - 与互斥锁不同，互斥锁的值本身不含有语义信息
- 信号量维护当前可用资源的数量，同时保证有且只有一个线程在使用该共享资源

#### 接口

- p操作：消耗资源
  - `void sem_wait(sem_t *sem)`
  - 荷兰语 passeren (pass)
- v操作：增加资源
  - `void sem_signal(sem_t *sem)`
  - 荷兰语 verhoog (increment)

#### 二元信号量与计数信号量

- 初始化信号量时，可以指定资源数量
  - `void sem_init(sem_t *sem, int init_cnt)`
- 当初始化数量 `init_cnt` 为1，则为**二元信号量**
  - 计数器只有0和1两个值
  - 同一时刻最多只有一个线程可以拿到该资源
- 当初始化数量大于1时，则为**计数信号量**
  - 同一时刻可能有多个线程可以拿到该资源

### 读写锁

- 如果使用一般的互斥锁实现读写操作，则一个线程在读的时候，其他线程都不能读
  - 但是读者之间并不互斥
    - 因为至少需要一个写操作才会发生竞争
- 读写锁区分读者和写者，允许读者之间并行
  - 读者和写者之间互斥
  - 写者和写者之间互斥

#### 接口

- `lock_reader()` `unlock_reader()`
- `lock_writer()` `unlock_writer()`

#### 读写协调

- 如果有很多读者一直轮流读取数据，则写者可能被饿死
  - 解决方案之一是，在有写者等待时，读者临界区“只出不进”

### 同步原语之间的比较

#### 互斥锁、条件变量、信号量

- 互斥锁与二元信号量功能类似，但是抽象不同
  - 互斥锁有拥有者的概念，一般同一个线程拿锁、放锁
  - 信号量没有锁的拥有者这样的概念，注重资源协调，一般一个线程signal，一个线程wait
  - 但是两者在功能上一般可以互相替代
- 条件变量用于解决睡眠、唤醒的问题，而且需要搭配互斥锁使用
  - 调用条件变量的接口时需要提供一个 `lock`

#### 互斥锁、读写锁

- 接口不同
- 针对场景不同
- 读写锁在读多、写少的场景中可以显著提高读者并行度，进而提高性能
- 只使用写者锁时，则与互斥锁的语义基本相同

## 死锁

> “一个人拿着A锁等B锁，另一个人拿着B锁等A锁”

### 产生原因

- 互斥访问
  - 同一时刻只有一个线程能访问某个资源
- 持有并等待
- 资源非抢占
- 循环等待

### 应对策略

#### 死锁检测与恢复

> “出了问题再处理”

- 建立资源分配图
- 如果资源分配图上有环，则表示出现循环等待
  - kill掉循环中的所有线程
  - kill一个线程，检查是否还有环，持续到分配图中不存在环
  - 全部回滚到之前的某个状态，然后~~祈祷~~检查回滚后重新运行是否还是遇到死锁

#### 死锁预防

##### 避免互斥访问

- 避免直接操作共享变量
- 通过代理线程操作
  - 只有代理线程能够访问共享资源
  - 其他线程发送修改请求，由代理线程统一执行

##### 不允许持有并等待

- 每个线程一次性申请自己需要的所有:lock:
- 如果成功，则继续执行
- 如果失败，则释放所有成功获得的:lock:，等待并重新尝试申请所有需要的:lock:

###### 活锁

- 线程A和线程B都需要锁M和锁N
  - A申请到了M，B申请到了N
  - A申请N失败，B申请M失败
  - A和B释放各自拿到的锁，重新尝试申请M和N
  - A申请到了M，B申请到了N
  - A申请N失败，B申请M失败
  - 寄！
- 但是活锁有机会自行恢复

##### 资源允许抢占

- 允许根据某些策略让一个线程抢占另一个线程持有的锁
  - 线程A抢占线程B的锁后，需要让线程B正确回滚到拿到锁之前的状态

##### 打破循环等待

- 按照特定顺序获取资源
- 对所有资源进行编号
- 让所有线程按资源编号顺序申请锁
  - 不会出现拿着A等B、拿着B等A
  - 因为所有线程都应该先拿A再拿B
  - 如果因为控制流原因，出现了先拿到了B又需要拿A的情况，则应先释放B

#### 死锁避免：银行家算法

- 所有线程获取锁需要经过管理者同意
- 管理者预演是否会造成死锁
  - 如果会，则阻塞线程，下次再同意
  - 否则正常给线程分配资源
