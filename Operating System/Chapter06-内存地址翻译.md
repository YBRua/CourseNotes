# 内存地址翻译

## 物理地址

### 问题

> “编译器会非常郁闷”

- 运行时物理内存地址被占用
- 物理内存不够

### 解决方案

- 假设应用运行时会独占所有内存，且内存足够大
  - 虚拟内存空间：$2^{32}$ Byte 或 $2^{64}$ Byte
- CPU将物理地址翻译到虚拟地址，由操作系统来配置如何翻译

## 虚拟地址

### CPU访问虚拟地址

- 通过 Memory Management Unit (MMU) 按照一定的规则进行翻译

### 分段机制

#### 直觉

- 虚拟地址分为 `段号` 与 `段内地址`
  - `段号` 由操作系统决定
    - 根据 `段号` 给 `段内地址` 增加偏移量
  - `段内地址` 由编译器生成
  - 由操作系统配置 `段表`，CPU查表翻译内存地址
  - `段表` 存在内存里，CPU只记录 `段表` 的初始地址和偏移量
- 每个段的长度是可变的

#### 细粒度分段

- 按代码、数据、堆、栈等，将一个程序分成多个段

#### 问题

- 对物理内存连续性的要求
  - 物理内存必须以段为单位进行分配
- 内存利用率
  - 外部碎片：段与段之间留下的碎片空间
  - 内部碎片：段内预留的未使用的碎片空间

### 分页机制

- 分页
  - 虚拟地址空间划分为**连续、等长**的虚拟页
  - 物理内存也划分为连续、等长的虚拟页
  - 虚拟内存和物理内存的页长度相等
- 虚拟地址记录为 `虚拟页号` + `页内偏移`
  - 翻译时只把 `虚拟页号` 翻译到 `物理页号`
  - `页内偏移` 不会因翻译而改变
- 使用页表进行内存映射

### 优势

- 物理内存离散分配
  - 任意虚拟页可以映射到任意物理页
  - 降低内存连续性要求
- 主存资源利用率更高

## 内存翻译

- 参数
  - $N = 2^n$ 为虚拟地址限制
  - $M = 2^m$ 为物理地址限制
  - $P = 2^p$ 为页的大小
  - $V = \{0,1,\dots,N-1\}$ 为虚拟地址空间
  - $P = \{0,1,\dots,M-1\}$ 为物理地址空间
- $Map(a): V \mapsto P \cup \{\emptyset\}$
  - 若虚拟地址 $a$ 的数据不在物理地址空间，或在磁盘上，则返回值为 $\emptyset$，触发缺页异常
  - 若虚拟地址 $a$ 的数据存在物理地址 $a'$，则返回 $a'$

## ARM64架构的内存翻译

### 多级页表

#### 单级页表的问题

- 假设64位虚拟地址空间，页大小为4KB，页表项为8字节（64位内存地址）
- 则需要 $2^{64} / 4K * 8 = ExtremelyManyGB \approx 33PB$
- 噔噔咚
- 事实上即使是32位虚拟地址空间，也需要 $4MB$
  - 在进程较多的情况下这也是不可接受的
- 单级页表是稀疏的

#### 多级页表

- 如果某一级页表的条目为空，则下一级页表也不存在，则无需给次级页表分配内存空间

#### AARCH64的多级页表

- AARCH64体系结构下最常见的是4级页表
- 前16个bit `63:48` 必须全是 `0` 或 `1`
  - 虚拟空间最大为 $2^{48}$，即 256TB
- `47:39` 0级页表索引
- `38:30` 1级页表索引
- `29:21` 2级页表索引
- `20:12` 3级页表索引
- `12:0` 页内偏移（页大小为4KB）

### 页表基地址寄存器

- AARCH64 体系结构下有两个基地址寄存器
  - `TTBR0_EL1`：应用程序
  - `TTBR1_EL1`：操作系统
  - 根据虚拟地址第 `63` 位选择

### 页表使能

- 机器上电时会进入物理寻址模式
  - 需要配置寄存器使能页表，然后进入虚拟寻址模式
- AARCH64 体系结构下需要将 `SCTLR_EL1` 第 `0` 位置为1

### 页表页

- 每级页表有若干离散的页表页
  - 每一个页表页占用一个物理页
- 第0级页表有且只有一个页表页
- 每个页表页中有512条
  - 每页4KB，每个条目8Byte，因此共512条

#### Level3 页表项

- 一个页表索引占不满64位，为了对齐时利用空间，空余的位（末12位和首16位）被用于存储权限等信息
  - `0` 位表示该项是否有效
  - `1` 位必须是1
  - `54` 位 `XN` 为1则表示 EL0 不能执行
  - `53` 位 `PXN` 为1则表示 EL1 不能执行
  - `51` 位 `DBM` 为1则表示该页被修改了

## Translation Lookaside Buffer TLB

- 多级页表压缩了页表大小，但是增加了内存访问次数
- TLB可以看作页表的缓存
  - 线性查找表，但是在硬件实现中可以并行化
  - 缓存有限数目的页表项
    - 大约几千项
- 翻译地址时，先查TLB
  - 如果 TLB 命中，则直接从TLB获取物理地址
  - 否则就寄了，还是得查页表
  - 但是查页表的时候也是读内存的流程，所以可能会先去查（真正的）Cache
    - 如果Cache里有页表条目，则可以少一次访存操作

### TLB刷新

- 在主流CPU里，TLB对程序员几乎不可见
  - 程序员可以主动flush TLB，但是通常不能做进一步操作
- 在修改 `TTBR` 寄存器时，整个 TLB 都会被刷新
  - 否则就要读错内存力
  - 但是在切换进程时会发生大量的TLB Miss

#### Address Space ID ASID

- OS 为不同进程分配8位或16位ASID
  - ASID位数由寄存器 `TCR_EL1` 的第36位决定
- OS会将ASID填写在 `TTBR0_EL1` 的高8位或高16位
- TLB的每一项也会存储 ASID
  - 读TLB时会额外匹配TLB的ASID和 `TTBR0_EL1` 的ASID
  - 若ASID不匹配，则认为TLB Miss
- 切换进程后不再需要刷新TLB
- 但是修改了页表映射后仍然需要手动刷新TLB

#### 刷新TLB的指令

- 清空全部
- 清空指定虚拟地址
  - 可用于修改了页表映射后
- 清空指定ASID
  - 可用于进程非常多导致ASID冲突时

#### 多核

- 假设一个核改了页表映射，需要同时刷新其他核的TLB
  - 因为一个进程可能在多个核上运行
- OS直到进程的调度信息，因此可以知道需要告知哪些核刷新TLB
- x86_64通过发送中断让某个核主动刷新
- AARM64 可以在local CPU上刷新其他核的 TLB
