# 虚拟内存管理

## 虚拟内存段和 VMA

### 段

- OS采用**段**管理虚拟地址，每个段包含了起始结束地址范围、读写权限等信息
  - 段内连续，段间非连续
  - 合法虚拟地址段：代码、数据、堆、栈
  - 非法虚拟地址段：未映射的代码段
    - 一旦访问则触发 `Segmentation Fault`
- 记录应用程序中已分配的虚拟地址区域
  - 代码段：读、执行
  - 数据段：读
  - 堆：读、写
  - 栈：读、写

### VMA

Linux 中采用 VMA 结构体记录应用程序已经分配的虚拟内存区域

#### 添加 VMA

- 途径1：OS在创建应用程序时分配
  - 数据
  - 代码
  - 栈（初始为空）  
- 途径2：应用程序主动向OS发出请求
  - `brk()`：扩大、缩小堆区域
    - OS也可以在应用程序创建时分配初始的堆的VMA
  - `mmap()`：申请空的虚拟内存区域，或申请文件内存映射的虚拟内存区域
- 用户态的 `malloc()` 也会改变VMA
  - 通常是调用 `brk`
  - 但是部分实现也会调用 `mmap`

#### `mmap`

- 通常用于把一个文件（或文件的一部分）映射到内存

```c
void *mmap(
    void *addr, //手动指定虚拟内存起始地址
    size_t length, // 手动指定虚拟内存区域长度
    int prot,
    int flags,
    int fd,
    off_t offset)
```

- 也可以不映射任何文件，仅仅新建虚拟内存区域
  - `fd=-1`
  - 并非POSIX标准，但是主流OS通常都会支持这一功能
- OS 不允许两块 `mmap` 的内存区域重叠
- 执行 `mmap` 后，VMA 中新增一个 `mmap` 开出来的段

```text


┌─────────────┐       ┌─────────────┐
│             │       │             │
├─────────────┤       ├─────────────┤
│    Stack    │       │    Stack    │
├─────────────┤       ├─────────────┤
│             │       │             │
│             │       ├─────────────┤
│             ├──────►│   mmapped   │
│             │       ├─────────────┤
│             │       │             │
├─────────────┤       ├─────────────┤
│    Heap     │       │    Heap     │
├─────────────┤       ├─────────────┤
└─────────────┘       └─────────────┘
```

#### VMA 与页表

- OS通过VMA记录应用程序能够访问的虚拟地址
  - 未映射的区域没有对应的VMA结构
- OS通过页表控制应用程序能访问的虚拟地址
  - 未分配的虚拟地址没有页表

#### 操作系统填写页表

- 立即映射
  - 每个虚拟页都对应一个物理页
- 延迟映射
  - 有些虚拟页不对应任何物理页
  - 对应的数据在磁盘上
  - 没有对应的数据（初始化为0）

!!!question VMA是否冗余
    如果只有立即映射一种模式，那么页表和VMA的功能有重叠，VMA会显得多余，但是仍然可以帮助OS快速判断一个虚拟地址是否合法。
    在增加了延迟映射的情况下，有些已分配的虚拟地址也没有页表项，因此需要VMA。

## 延迟映射-按需调页 Demand Paging

### 物理内存作为虚拟地址空间的Cache

#### 为什么

- 有时应用程序所需的物理内存总和超出了机器上实际搭载的物理内存总量
  - 对应[换页机制](#换页机制)
- 有时应用程序预先申请了很大的内存，但是很多虚拟页最终都没有用到
  - 对应[按需调页](#延迟映射-按需调页-demand-paging)

### 流程

当应用程序申请分配内存时，操作系统可以将新分配的虚拟页标记成 *已分配，但未映射在物理内存中* 的状态，而不必立刻为这个虚拟页分配对应的物理页

1. 操作系统为应用程序创建VMA，但是并不把整个应用程序加载到内存
   - “先画个饼”
2. CPU访存时发现没有页表项没有对应的物理页映射
3. 触发 `Page Fault`
4. OS处理 `Page Fault`
   1. 检查VMA
   2. 根据VMA分配并初始化内存，此时才真正分配物理页
   3. 更新页表
5. 回到用户态，重新运行访存指令

!!!note
    只在触发了 `Page Fault` 时（即应用程序真的需要访问对应的物理页时）才分配物理内存，节省了物理内存使用。

    这会导致初次访存时总会触发 `Page Fault`。操作系统利用程序访存的**空间局部性**特点，可以进行预先映射（prefetch），即把缺页异常的虚拟页附近的虚拟页也一并进行映射，从而减少未来可能发生缺页异常的次数。

## 换页机制

### 基本思想

- 用磁盘作为物理内存的补充，且对上层应用透明
- 应用对虚拟内存的使用不受物理内存大小限制
- “骗应用程序说我有很大很大很大的物理内存”

### 基本实现

- 磁盘上划分专门的Swap分区或Swap文件
- 在处理缺页异常时，触发物理内存页的换入换出
- Swap-out
  - 将数据写入磁盘Swap分区（或写回backup file），在该进程的页表中抹去对应虚拟地址到该物理页的映射，并记录虚拟地址和磁盘块的对应关系
  - 此后该物理页可以被操作系统回收并提供给其他应用程序使用
  - 原进程的虚拟页此时将处在已经分配、但是未映射在物理内存中的状态
- Swap-in
  - 将数据从磁盘写回内存，重新建立映射

### 页命中与缺页异常

#### 页命中

- CPU将虚拟地址发送给MMU
- MMU查TLB，如果未命中则从页表中取出页表项
- MMU将物理地址发送给Cache或内存
- Cache或内存将内容返回给CPU

#### Page Fault

- CPU将虚拟地址发送个MMU
- MMU查TLB，如果未命中则从页表中取出页表项
- 页表项有效位为`0`，触发`Page Fault`
- Handler找到一个victim page
  - 如果该页被修改过，则需要写回磁盘
- Handler将新的页载入内存，并修改页表
- Handler返回触发`Page Fault`的指令，重新运行

!!!note SWAP
    如果物理内存耗尽，那么操作系统会疯狂读写SWAP进行换页，在使用机械硬盘时会显著拖慢系统性能，在使用固态硬盘时虽然系统性能不会下降得太严重，但是频繁读写也会损耗固态硬盘寿命

!!!info 内存管理API
    `madvice` 函数将用户态的一些信息发送给内核以便于优化，**建议**操作系统提前分配物理页，减少缺页异常造成的性能开销
    `mprotect` 函数改变内存权限

## 其他内存管理机制

### 共享内存

- 将两个进程的虚拟内存映射到同一段物理地址
  - 节约内存，例如使用共享库时
  - 可以实现进程间通信
- 基于共享内存，又衍生出写时拷贝、内存去重等功能

### 写时拷贝 Copy-on-Write

- 常见于 fork
- 父子进程共享一段只读物理内存
- 如果某个进程要写物理内存，则在写之前OS会复制一页并修改权限为可写
  - 在尝试写共享物理内存页时，同样会触发缺页异常，但是处理函数知道这是被标记为写时拷贝的页，因此会做出对应处理
- 常用于性能优化

### 内存去重

- 操作系统中有专门扫描内存的进程
- 用于合并具有相同内容的物理页
- 由操作系统发起，对用户态透明
- 但是可能会对程序访存时延造成影响
  - 应用程序尝试写一个被去重的内存页时，又会触发缺页异常，并触发写时拷贝

### 内存压缩

- 将多个内存页的数据压缩成单个内存页，存放在专门的内存区域
  - 称为 ZSWAP
- 例如全零的页或稀疏的页

### 大页

- 将二级页表中一个条目指向的三级页表（512页）全部合并为一个页
- 共 $512\times 4\mathsf{K}=2\mathsf{M}$
  - 降低对页表的操作，同时降低TLB占用（一个大页在TLB中只占一项）
  - 代价是可能会造成内部碎片和浪费，而且增加了内存管理的复杂度
- 类似地也可以把L1页表项之后的页表全部合并，指向一个1G的内存页
  - 可能用于云端服务器开虚拟机时

## 虚拟地址的优势

- 把目前不太充足的物理内存“变大”
- 简化应用程序开发和编译器设计时的地址管理
  - 对应用程序而言，它看到的永远是完整的、连续的虚拟地址空间
- 较为便捷地实现权限管理、内存共享
- 结合VMA让程序启动更加快速
