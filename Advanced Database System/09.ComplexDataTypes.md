# Complex Data Types

- Traditional relational model requires that *data values be atomic*.
- Multivalued, composite, and other complex data types are not allowed by the core relational model.

## Semi-Structured Data

### Motivation

- Relational database have tables with a *fixed* number of attributes.
  - Each of which contains an atomic value.
  - Changes to the schema are rare, and might require changing application code.
- Many applications need to store more complex data whose schemas often change.
- Another motivation for semi-structured data is data exchange (e.g., server-client data exchange in web applications)

### Overview of Semi-Structured Data Models

#### Flexible Schema

**Wide Column.** Some database systems allow each tuple to potentially have a different set of attributes. Such a representation is referred to as a **wide column** data representation.

**Sparse Column.** A more restricted version of the wide column representation is to have a fixed but very large number of attributes. Each tuple only uses the attributes that it needs, leaving the rest with null values.

#### Multivalued Data

- Many databases allow the storage of *non-atomic values*.
  - Sets, multisets.
  - Key-value maps.
  - Arrays.

#### Nested Data Types

- JSON, XML

#### Knowledge Representation

- Resource Description Format (RDF)

### JSON

- JavaScript Object Notation.
- A textual representation of complex data types that is widely used between applications for communication.

### XML

- The XML data representation adds **tags** enclosed in angled brackets to mark up information in a textual representation.
- Tags can be used to represent relational data by specifying relation names and attributes as tags.

### RDF

- The **Resource Description Framework (RDF)** is a data representation standard based on the *entity-relation* model.
- Represents data by a set of **triples** in one of the two forms
  1. (id, attribute-name, value)
  2. (id1, relationship, id2)
- id, id1, id2 are identifiers of *entities* (a.k.a. *resources* in RDF).
- Only supports binary relationships; does not support n-ary relationships.
  - n-ary relationships can be converted to multiple binary relationships.

#### Knowledge Graph

- The RDF data has a very natural graph representation, known as **knowledge graphs**.
  - Entities and attributes are nodes.
  - Attribute names and relationships are edges.

#### SPARQL

- A query language designed to query RDF data, based on triple patterns.
- Looks like RDF triples, but contains variables.

```plain
// matches all triples whose predicate is "title" and object is "Intro. to CS"
?cid title "Introduction to Computer Science"
```

## Object Orientation

The **object-relational data model** extends the relational data model by providing a *richer* type system.

Three approaches for integrating object orientation with database systems.

1. **Object-relational database system.** Adds object-oriented features to a relational database system.
2. **Object-relational mapping (ORM).** Convert object-oriented type system of a programming language to a relational representation for storage, and vice versa.
3. **Object-oriented database system.** A database system that natively supports object-oriented type systems.
   - Does not support declarative querying
   - Increases risk of database corruption due to pointer errors.


### Object-Relational Database Systems

#### User-Defined Types (UDT)

Object extensions to SQL allow creation of structured user-defined types

```sql
CREATE TYPE AddressType (
  street VARCHAR(20),
  city VARCHAR(20)
) NOT FINAL;
```

- `FINAL` and `NOT FINAL` determines if the "class" can be inherited.

```sql
CREATE TYPE Person (
  ID VARCHAR(20) PRIMARY KEY,
  name VARCHAR(20),
  address AddressType
);
```

- UDT can be used as attributes of other UDTs.

```sql
CREATE TABLE persons OF Person;

SELECT name, address.city FROM persons;
```

##### Methods

UDT can also have associated **methods**, though only a few systems support this feature.

```sql
CREATE TYPE Person (
    name VARCHAR(20),
    address AddressType,
    dob DATE
) NOT FINAL;

METHOD ageOnDate (onDate date)
RETURNS interval YEAR;

CREATE instance method ageOnDate (onDate DATA)
RETURNS interval YEAR FOR Person
BEGIN
		RETURN onDate - self.dob;
END;
```

##### Constructor and Instance Creation

```sql
CREATE FUNCTION AddressType (s VARCHAR(20), c VARCHAR(20))
RETURNS AdressType
BEGIN
    SET self.street = s;
    SET self.city = c;
END;

INSERT INTO persons
VALUES ('Zhang San',
        NEW AddressType('800 Dongchuan', 'Shanghai'),
        DATE'1997-7-1');
```

#### Inheritance

```sql
CREATE TYPE Student UNDER Person AS (
    degree  VARCHAR(20),
    department  VARCHAR(20));
CREATE TYPE Teacher under Person AS (
    salary  INTEGER,
    department  VARCHAR(20));
```

- Derived types inherit the attributes (and methods) from the base type.
- Methods of the derived types could be overwritten.

#### Table Inheritance

**Table inheritance** allows a table to be declared as a subtable of another table.

```sql
CREATE TABLE students OF Student UNDER people;
CREATE TABLE teachers OF Teacher UNDER people;
```

- Type of the subtable must be subtypes of the parent table type.
- Every tuple in the subtables becomes *implicitly* present in the parent table.
  - E.g., querying people also returns tuples in Student and Teacher, but only the attributes on type People are returned.
  - use `SELECT * FROM ONLY people` to exclude implicit tuples.

##### Consistency Requirements on Subtables

- Tuples in the subtable and parent table should refer to the same entity.
  - I.e., they have identical values on the inherited attributes.
- Consistency of subtables.
  - Each tuple in the parent table corresponds to *at most one* tuple in on subtable.
    - E.g., The same tuple in people cannot corresponds to two tuples in student.
    - E.g., A person cannot exist in both teacher and student.
  - In SQL, it is further required that the tuples must be inserted by the same insertion query.

### Collections

- SQL 1999 added support for Array types, 2003 added support for multisets.

```sql
CREATE TYPE Book AS (
  title VARCHAR(20),
  authors VARCHAR(20) ARRAY [10],
  pub_date DATE,
  publisher Publisher,
  keywords VARCHAR(20) MULTISET
);
```

- Arrays can be indexed
  - `SELECT authors[1], authors[2] FROM books;`
- `UNNEST()` can be used for coverting collections to relations
  - `SELECT B.title, A.author FROM books as B, unnest(B.authors) as A(author)`.

## Textual Data

### Keyword Queries

- Information retrieval systems support retrieving documents with some desired information.
  - Typically described by a set of **keywords**.

### Relevance Ranking

- The set of all documents that contain the keywords in a query can be very large.
- Not all documents are equivalent to a keyword query.

#### TF-IDF

**Term Frequency (TF).** The relative frequency of term $t$ in document $d$.

$$ TF(t, d) = \log \left( 1 + \frac{n(d, t)}{n(d)} \right) $$

where $n(d,t)$ is the number of times $t$ occurs in $d$, $n(d) = \sum_{t' \in d} n(d, t')$ is the total number of terms in $d$.

**Inverted Document Frequency (IDF).** A measure of how much information a word provides.

$$ IDF(t, D) = \frac{1}{n(t)} $$

where $n(t)$ denotes the number of documents that contain $t$. 

$$ TFIDF(d, Q) = \sum_{t \in Q} TF(d, t) \times IDF(t) $$

Using IDF as a weight of TF.
