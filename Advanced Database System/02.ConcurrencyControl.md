# Concurrency Control

- Multiple concurrent transactions might break the consistency of a database.
- The system thus must control the interactions among concurrent transactions.
- The most frequently used schemes are *two-phase locking* and *snapshot isolation*.

## Lock-Based Protocols

- Require data items to be accessed in a *mutually exclusive* manner.
  - When a transaction is accessing an item, no other transaction can modify that item.
- **Lock.** Allow a transaction to access an data item only if the transaction is holding a **lock** on that item.

### Locks

- Two types of locks.
  - **Shared Lock (S).** If a transaction $T$ holds a **shared-mode lock** on item $Q$, $T$ can read, but cannot write, $Q$.
  - **Exclusive Lock (X).** If a transction $T$ holds an **exclusive-mode lock** on item $Q$, $T$ can both read and write $Q$.
- Every transaction is required to **request** a lock (in an appropriate mode) on data $Q$; it can proceed only after the concurrency-control manager **grants** the lock to it.

#### Compatibility of Locks

| Mode  |   S   |   X   |
| :---: | :---: | :---: |
|   S   | true  | false |
|   X   | false | false |

- Mode A is **compatible** with mode B if transaction $T$ can be immediately granted a mode-A lock in the presence of a mode-B lock.
- If the data item is locked in an incompatible mode, the concurrency-control manager will not grant the lock until all locks in incompatible mode have been released.

!!!note Waiting for Locks
    To access a data item, the transaction must hold the lock on that item. The lock is only granted if all incompatible locks held by other transactions are released.

    Otherwise, the transaction has to wait until it acquires the lock (i.e. wait until all incompatible locks are released)

!!!info Releasing Locks
    *It is not always desirable to immediately release the lock after a transaction's final access to the item, because this may lead to inconsitencies in some schedules.*

    “在你放锁的时候，可能发生很多事情。”

#### Deadlocks

- A **deadlock** occurs when a cycle of transactions wait for locks to be released by each other.
  - *“拿着锁等锁”*
- When a deadlock occurs, the system must roll back one (or more) transactions and release their locks.

### Locking Protocol

- A set of rules indicating when a transaction might lock and unlock each of the data items.

#### Terminologies

- Transaction $T_i$ **precedes** $T_j$ ($T_i \to T_j$) if there exists a data item $Q$ s.t. $T_i$ has held a lock $A$ on $Q$ and $T_j$ has held lock $B$ on $Q$, and $\mathtt{comp}(A, B) = \texttt{false}$.
- A schedule $S$ is **legal** under a given locking protocol if $S$ is a possible schedule for a set of transactions that follows the rules of the locking protocol.
- A locking protocol **ensures conflict serializability** if and only if all legal schedules are conflict serializable.
- A transaction is said to be **starved** if it keeps waiting for a lock without any progress.

#### Two-Phase Locking Protocol (2PL)

- **2PL** ensures conflict serializability.
- The protocol requires that each transaction issue lock and unlock requests in *two phases*
  1. **Growing Phase.** A transaction may obtain locks, but may not release any lock.
  2. **Shrinking Phase.** A transaction may release locks, but may not obtain any new locks.
- 2PL does NOT avoid deadlocks.
- 2PL does NOT avoid cascading rollbacks.

##### Lock Point

The point in the schedule where the transaction has obtained *its final lock* (the end of its growing phase) is called the **lock point** of the transaction.

- Transactions can be ordered according to their lock points.
- The ordering is a serializability ordering for the transactions.

> *事务：“我要读 $Q$！”*
> *系统：“不行。你去死。”*

##### Variants of 2PL

- **Strict 2PL (严格两阶段锁).**
  - Requires that all exclusive locks must be held until the transaction commits.
  - Avoids cascading rollbacks.
- **Rigorous 2PL (强两阶段锁).**
  - Requires that all locks must be held until the transaction commits.
  - With rigorous 2PL, transactions can be serialized in the order in which they commit.

##### Lock Conversions

- **Upgrade.** Conversion from shared to exclusive modes.
- **Downgrade.** Conversion from exclusive to shared modes.
- **2PL with Lock Conversion.**
  - In growing phase, transactions can acquire or upgrade locks.
  - In shrinking phase, transactions can release or downgrade locks.

Lock conversions allows better concurrency, and it also guarantees conflict serializability.

!!! note 2PL and Conflict Serializability
    There may be other conflict-serializable schedules that *cannot be obtained by 2PL*.

    - Obtaining other conflict-serializable schedules requires additional information, or specific structure or ordering of the database.
    - 2PL always produces conflict-serializable schedules.

### Implementation of Locking

Lock and unlock requests are handled by the lock manager. It maintains a **lock table**: a hash table over the lock entries, it maps locks to their entry queues.

#### Lock Table

- Essentially a hash table `Map<DataItem, LockEntryQueue>`
  - `DataItem` are the data items in the database.
  - `LockEntryQueue` is a linked list of transactions that have made request on the lock.
- On a lock request, the transaction is added to the entry queue.
  - Grants the lock if the item is not currently locked, or if the locks are compatible with the requested lock.
- On an unlock request, the first transaction in the queue is re-activated
- The lock table may also keep a list of locks held by each transaction
  - when a transaction aborts, the locks held by this transaction can be released efficiently

### Graph-based Locking Protocols

Assumes there exists a *partial ordering* $\to$ on the dataset $D = \{ d_1,\dots,d_h \}$ such that if $ d_i \to d_j $ then any transaction accessing $d_j$ must first access $d_i$.

#### Database Graph

**Database Graph.** The partial ordering implies that the dataset could be viewed as a *directed acyclic graph*.

#### Tree Protocol

- Designed for graphs that are *rooted trees.*
- Restricted to employ only exclusive locks.
  1. The first lock by $T_i$ may be on any item.
  2. Subsequently, a data item $Q$ can be locked by $T_i$ only if the parent of $Q$ is currently locked by $T_i$.
  3. Data items may be unlocked at any time.
  4. A data item that has been locked and unlocked by $T_i$ cannot be subsequently relocked by $T_i$.
- All legal schedules under the tree protocol are conflict serializable.

!!! info Remarks on Tree Protocol
    - Conflict Serializable.
    - Avoids deadlocks.
    - Better concurrency (compared with 2PL) because locks can be released any time.
    - In some cases, a transaction may have to lock items it does not access.
    - There may be conflict-serializable schedules that cannot obtained through the tree-protocol.

### Deadlock Handling

The remedy to deadlock is to roll back some of the transactions involved in the deadlock.

- Two principal methods for deadlock handling
  - **Deadlock Prevention.** Ensure the system will *never* enter a deadlock state.
  - **Deadlock Detection and Deadlock Recovery.** Allow the system to enter a deadlock state and try to recover from it.

#### Deadlock Prevention

##### Naive Prevention Scheme

Requires that each transaction locks all its data items before it begins execution.

Impose all ordering / Tree Protocol / All-or-None

- It is often hard to predict what items need to be locked before the transaction begins.
- Data utilization may be very low.

##### Preemptive Deadlock Prevention

- **Wait-Die.**
- **Wound-Wait.**

##### Lock Timeouts

#### Deadlock Detection and Recovery

##### Wait-for Graph

- **Wait-for Graph.** $G=(V,E)$
  - Vertices $V$ represents all transactions in the system
  - Edges $E$ is an ordered pair $T_i \to T_j$
    - $T_i \to T_j$ means $T_i$ is waiting for a lock held by $T_j$
- A deadlock exists if and only if the wait-for graph *contains a cycle*.
  - Each transaction in the cycle is said to be deadlocked.
- A function is periodically invoked to check for cycles in the graph.

### Multiple Lock Granularity

Allows the system to define multiple levels of locking granularity to improve concurrency.

- The lock can be placed on a tuple, a page, a table or the entire database
- Tradeoff between overhead and concurrency
  - Finer granularity: high concurrency, high locking overhead (both time and space cost)
  - Coarse granularity: low locking overhead, low concurrency
- The database hierarchy can be represented as a tree
  - When a transaction locks a node in the tree explicitly, all child nodes are also implicitly locked
  - A lock at lower level also affects locking the parent nodes
    - A more sophisticated locking mode is required