# Recovery

## Failure Classification

- **Transaction Failure.**
  - **Logic Error.** The transaction can no longer continue with its normal execution because of some internal condition
  - **System Error.** The system has entered an undesirable state (e.g., deadlock), as a result of which a transaction cannot continue with its normal execution
- **System Crash.** Hardware malfunction, or a bug in the database software or OS that causes the loss of the content of volatile storage and halts transaction processing.
  - **Fail-stop Assumption.** Assumes the halt does not corrupt non-volatile storage.
- **Disk Failure.** A disk block loses its content.

!!!note Notes on disk data I/O
    Workspace (Memory, Volatile) - Disk Buffer (Memory, Volatile) - Disk (Disk, Non-volatile)

## Log-based Recovery

!!!note Intuition of Logging
    Write what the DBMS **plan to do** in the log with enough information to tell the DBMS whether it has been done or not.

    **Note that the log records always go to the disk before the actual modification.**

- To achieve atomicity, the DBMS first outputs information *describing the modifications* to stable storage, before actually modifying the database itself.
- The most widely used structure for recording database modifications is the **log**.
- The **log** is a sequence of **log records**.

### Types of Log Records

- **Update log record.** $<T_i, X, V_{old}, V_{new}>$ describes a write operation, it contains
  - Transaction ID $T_i$, data item $X$, old and new values $V_{old}$, $V_{new}$.
- **Start of Transaction.** $<T_i, \mathtt{start}>$
- **Commit of Transaction.** $<T_i, \mathtt{commit}>$
- **Abort of Transaction.** $<T_i, \mathtt{abort}>$

Whenever a transaction performs a write, it is essential that *the log record for that write be created and added to the log, before the database is modified*.

- Once a log exists, we can output the update back to the database;
- we can also undo a modification that already has been written back to the database by using the *old value* field in the log.
- Assume (for now) that log records are written to disk (stable storage) as soon as they are created.

### Database Modification

The steps a transaction takes to update an item

1. It performs some computations in its own private part of main memory.
2. It modifies the data block in the disk buffer in main memory holding the data item.
3. It writes the data block back to disk.

A transaction **modifies the database** if it performs an update on a disk buffer, or on the disk itself.

- It uses **deferred-modification** technique if it does not modify the database until it has committed.
  - Overhead: transactions need to make local copies of all modified items
  - If a transaction reads an item, it also must read the item from its local copy
- It uses **immediate-modification** if database modifications occur when the transaction is still active.

#### Requirements on the Recovery Algorithm

The recovery algorithm must take into account a variety of factors

- A transaction has committed, but some of its modifications are not written back to disk.
  - Recover with the **redo** operation. Set the data item specified in the log record to the new value specified in the log.
- A transaction has modified the database while in active state, but it needs to abort due to subsequent failures.
  - Recover with the **undo** operation. Set the data item specified in the log record to the old value specified in the log.

### Concurrency Control and Recovery

### Transaction Commit

- A transaction has **committed** when its commit log record (the last log record of a transaction) has been output to stable storage.
  - At which point all earlier log records have also been output to stable storage.
  - We can then recover the database even if the system crashes.
- If a system crash occurs *before* $<T_i, \mathtt{commit}>$, then $T_i$ would be rolled back.
  - Therefore, the commit log record is the single atomic action that results in a transaction getting committed.
- With most log-based recovery techniques, blocks containing the data items modified by a transaction do not have to be output to stable storage when the transaction commits.

### Redo and Undo

#### Redo

The **redo** procedure sets the values of all data items updated by $T_i$ to the new values.

- Performs a single forward scan of the log.
- Redo actions are performed for each log record that is encountered.
  - Ensures the order of the modifications.
  - The log only needs to be scanned once, instead of redoing for each transcation

#### Undo

The **undo** procedure restores the values updated by $T_i$ to old values.

- Performs a single *backward* scan of the log, and *only undos items modified by $T_i$*.
- Not only restores data items, but also writes log records to record the updates.
  - The log records are special **redo-only** records, since they only contain the new values ($V_{old}$ during the undo process) and do not need to contain the old values ($V_{new}$).
- When the undo for $T_i$ completes, it writes a $<T_i, \mathtt{abort}>$ log record, indicating the undo has completed.

#### Recovery

When the system recovers from a crash, it consults the log to determine which transactions need to be redone and which need to be undone.

- A transaction needs to be **undone** if the log contains a $\mathtt{start}$, but does not contain either $\mathtt{commit}$ or $\mathtt{abort}$.
- A transaction needs to be **redone** if the log contains a $\mathtt{start}$ and a $\mathtt{commit}$ or $\mathtt{abort}$.
  - Note that we also need to redo $\mathtt{abort}$ transactions because *the redo-only records also exist in the log*. The redo here is actually re-performing the undo procedure of $T_i$.

### Checkpoints

Searching the entire log could be difficult

1. The search process is time-consuming.
2. Most of the transactions that need to be redone have already written their updates into the database, and they actually do not need to be redone.

**Checkpoints** are introduced to reduce such overheads.

#### Procedure of Checkpointing

1. Output all log records currently in main memory to stable storage.
2. Output all modified buffer blocks to disk.
3. Output a record $<\mathtt{checkpoint},L>$ where $L$ is a list of transactions active at the time of checkpointing.

- Transactions are not allowed to perform any update operations while a checkpoint is in progress.
- Typically a checkpoint is performed once 1-2 minutes.

#### Recovery with Checkpoints

The checkpoints improve the performance of recovery.

- If $T_i$ has completed prior to the checkpoint, it does not need to be redone.
  - Any modification by $T_i$ must have been written to the disk ($\mathtt{commit}$ or $\mathtt{abort}$ must appear before the $\mathtt{checkpoint}$).
- During recovery, the system examines the log to find the *last* checkpoint record.
- The undo and redo operations only need to be applied to transactions in $L$ and those started after the checkpoint.

## Recovery Algorithm

### Transaction Rollback

- Backward scan the log, for each log record of $T_i$ of the form $<T_i, X, V_1, V_2>$.
  - Write $V_1$ to $X$.
  - Write a special redo-only log record $<T_i, X, V_1>$ to the log.
    - The record is also known as **compensation log records**.
- Stop the scan when $<T_i, \mathtt{start}>$ is encountered.
- Append $<T_i, \mathtt{abort}>$ to the log.

### Recovery after a Crash

The recovery actions consists of a redo stage and an undo stage.

#### Redo Phase

The system replays the update of all transactions. (**repeating history **)

- Scan the log forward from the last checkpoint.
- Redo all transactions, including those that have been rolled back and those that have not yet committed.
- This phase also determines the transactions that are incomplete and need to be rolled back.
  - Those without commit or abort records.

The specific steps are as follows

1. The list of transactions to be rolled back is initialized with $L$.
2. Whenever a normal log record $<T_i, X, V_1, V_2>$ or a redo-only log record $<T_i, X, V_2>$ is encountered, the operation is redone.
3. Whenenver a start record $<T_j, \mathtt{start}>$ is encountered, $T_j$ is added to the undo-list.
4. Whenever a commit or abort record of $T_j$ is encountered, $T_j$ is removed from the undo-list.

At the end of the redo phase, the undo-list contains all incomplete transactions that need to be undone.

#### Undo Phase

In the undo phase, the DBMS performs rollback by scanning the log backward.

1. Whenever it encounters a transaction in the undo-list, it undoes the operation and writes a compensation log.
2. Whenever it encouters $<T_j, \mathtt{start}>$, it writes a $<T_j, \mathtt{abort}>$ record to the log and removes $T_j$ from the undo-list.
3. The undo phase terminates once the undo-list becomes empty.

### Commit Processing Optimizations; Group-Commit

- Instead of forcing the log as soon as a transaction completes
- The system waits until several transactions have completed, or a certain period of time has passed since a transaction completed execution.
- It then commits the group of transactions that are waiting together.

This technique results, on average, in fewer output operations per committed transaction.

It results in a slight delay in commit of transactions that perform updates, but with high rates of transaction commit, the overall delay in commit is actually reduced.

## Buffer Management

Implementation details of a crash-recovery scheme.

### Log-Record Buffering

The cost of outputting a block to stable storage is high, but a single record is much smaller than a block. It is desirable to output multiple log records at once.

- Multiple log records can be gathered in the log buffer and output to stable storage in a single output operation.
  - Log records are first written to a log buffer in main memory.
  - Multiple records can be gathered together in the buffer and output to stable storage in a single operation.
- As a result, the log records might reside in main memory and get lost if the system crashes.

#### Write-Ahead Logging (WAL)

